// <autogenerated>
//   This file was generated by dddappp code generator.
//   Any changes made to this file manually will be lost next time the file is regenerated.
// </autogenerated>

package org.dddml.ffvtraceability.domain.inventoryitem;

import com.fasterxml.jackson.databind.ObjectMapper;
import org.dddml.ffvtraceability.domain.mapper.InventoryItemMapper;
import org.dddml.ffvtraceability.specialization.DomainError;
import org.dddml.ffvtraceability.specialization.MutationContext;
import org.dddml.ffvtraceability.specialization.VerificationContext;
import org.erdtman.jcs.JsonCanonicalizer;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import org.springframework.util.DigestUtils;

import java.math.BigDecimal;
import java.nio.charset.StandardCharsets;


/**
 * Implementation of the InventoryItem.RecordInventoryEntry command logic.
 */
@Component("(inventoryItem_RecordInventoryEntry)")
public class RecordInventoryEntryLogic implements IRecordInventoryEntryLogic {

    private static ObjectMapper objectMapper;

    static {
        objectMapper = new com.fasterxml.jackson.databind.ObjectMapper();
        objectMapper.setSerializationInclusion(com.fasterxml.jackson.annotation.JsonInclude.Include.NON_NULL);
        objectMapper.configure(com.fasterxml.jackson.databind.DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false); // 反序列化时忽略未知属性
        objectMapper.registerModule(new com.fasterxml.jackson.datatype.jsr310.JavaTimeModule())
                .setDateFormat(new com.fasterxml.jackson.databind.util.StdDateFormat().withColonInTimeZone(true))
                .configure(com.fasterxml.jackson.databind.SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false)
                .configure(com.fasterxml.jackson.databind.SerializationFeature.WRITE_DATE_TIMESTAMPS_AS_NANOSECONDS, false)
                .configure(com.fasterxml.jackson.databind.DeserializationFeature.ADJUST_DATES_TO_CONTEXT_TIME_ZONE, false);
    }

    @Autowired
    private InventoryItemMapper inventoryItemMapper;

    /**
     * Verifies the InventoryItem.RecordInventoryEntry command by performing validation logic
     * before the state mutation. Creates and returns an event.
     *
     * @param eventFactory                  The supplier that creates new InventoryItemEvent.RecordInventoryEntryEvent events
     * @param inventoryItemState            The current state of the InventoryItem aggregate
     * @param inventoryItemAttributes
     * @param inventoryItemDetailAttributes
     * @param quantityOnHandDiff
     * @param availableToPromiseDiff
     * @param accountingQuantityDiff
     * @param unitCost
     * @param verificationContext           The context information for the verification process
     * @return An event that will be applied to the current state to update the InventoryItem
     */
    public InventoryItemEvent.RecordInventoryEntryEvent verify(
            java.util.function.Supplier<InventoryItemEvent.RecordInventoryEntryEvent> eventFactory,
            InventoryItemState inventoryItemState,
            InventoryItemAttributes inventoryItemAttributes,
            InventoryItemDetailAttributes inventoryItemDetailAttributes,
            java.math.BigDecimal quantityOnHandDiff,
            java.math.BigDecimal availableToPromiseDiff,
            java.math.BigDecimal accountingQuantityDiff,
            java.math.BigDecimal unitCost,
            VerificationContext verificationContext
    ) {
        InventoryItemEvent.RecordInventoryEntryEvent e = eventFactory.get();

        // TODO: verification logic?
        return e;
    }

    private String getInventoryItemAttributesHash(InventoryItemAttributes inventoryItemAttributes) {
        try {
            String json = objectMapper.writeValueAsString(inventoryItemAttributes);
            JsonCanonicalizer jc = new JsonCanonicalizer(json);
            String encoded = jc.getEncodedString();
            return DigestUtils.md5DigestAsHex(encoded.getBytes(StandardCharsets.UTF_8));
        } catch (Exception e) {
            throw DomainError.named("CannotCalculateInventoryItemId", "Cannot calculate inventory item id");
        }
    }

    private String getInventoryItemDetailAttributesHash(InventoryItemDetailAttributes inventoryItemDetailAttributes) {
        try {
            String json = objectMapper.writeValueAsString(inventoryItemDetailAttributes);
            JsonCanonicalizer jc = new JsonCanonicalizer(json);
            String encoded = jc.getEncodedString();
            return DigestUtils.md5DigestAsHex(encoded.getBytes(StandardCharsets.UTF_8));
        } catch (Exception e) {
            throw DomainError.named("CannotCalculateInventoryItemDetailId", "Cannot calculate inventory item detail id");
        }
    }


    /**
     * Performs the state mutation operation of InventoryItem.RecordInventoryEntry command.
     *
     * @param inventoryItemState            The current immutable state of the InventoryItem
     * @param inventoryItemAttributes
     * @param inventoryItemDetailAttributes
     * @param quantityOnHandDiff
     * @param availableToPromiseDiff
     * @param accountingQuantityDiff
     * @param unitCost
     * @param mutationContext               The context that provides functionality including creating mutable state
     * @return The new state of the InventoryItem
     */
    public InventoryItemState mutate(
            InventoryItemState inventoryItemState,
            InventoryItemAttributes inventoryItemAttributes,
            InventoryItemDetailAttributes inventoryItemDetailAttributes,
            java.math.BigDecimal quantityOnHandDiff,
            java.math.BigDecimal availableToPromiseDiff,
            java.math.BigDecimal accountingQuantityDiff,
            java.math.BigDecimal unitCost,
            MutationContext<InventoryItemState, InventoryItemState.MutableInventoryItemState> mutationContext
    ) {
        InventoryItemState.MutableInventoryItemState mutableInventoryItemState;
        String itemAttrHash = null;
        if (inventoryItemState == null) {
            if (inventoryItemAttributes == null) {
                throw DomainError.named("InvalidAttributes", "InventoryItem attributes are required");
            }
            itemAttrHash = getInventoryItemAttributesHash(inventoryItemAttributes);
            mutableInventoryItemState = mutationContext.newMutableStateById(itemAttrHash);
            if (mutableInventoryItemState.getInventoryItemAttributeHash() == null) {
                mutableInventoryItemState.setInventoryItemAttributeHash(itemAttrHash);
                inventoryItemMapper.updateInventoryItemState(mutableInventoryItemState, inventoryItemAttributes);
            } else {
                //TODO: If the inventory item already exists?
            }
        } else {
            mutableInventoryItemState = mutationContext.toMutableState(inventoryItemState);
            if (inventoryItemAttributes != null) {
                throw DomainError.named("InvalidOperation",
                        "Cannot modify inventory item attributes for existing inventory item");
            }
        }

        if (mutableInventoryItemState == null) {
            throw DomainError.named("InvalidState", "Failed to create or retrieve mutable inventory item state");
        }

        // Create inventory item detail
        if (inventoryItemDetailAttributes == null) {
            throw DomainError.named("InvalidAttributes", "InventoryItem detail attributes are required for new inventory item");
        }

        String detailAttrHash = getInventoryItemDetailAttributesHash(inventoryItemDetailAttributes);
        InventoryItemDetailState.MutableInventoryItemDetailState detailState
                = mutableInventoryItemState.getDetails().getOrAddMutableState(detailAttrHash);
        if (detailState.getInventoryItemDetailAttributeHash() != null) {
            throw DomainError.named("InvalidOperation",
                    "Cannot modify inventory item detail attributes for existing inventory item detail");
        }
        detailState.setInventoryItemAttributeHash(itemAttrHash);
        detailState.setInventoryItemDetailAttributeHash(detailAttrHash);
        inventoryItemMapper.updateInventoryItemDetailState(detailState, inventoryItemDetailAttributes);


        // Process quantity changes - standardized for both new and existing items
        // Handle quantityOnHand
        BigDecimal qohDiff = quantityOnHandDiff == null ? BigDecimal.ZERO : quantityOnHandDiff;
        detailState.setQuantityOnHandDiff(qohDiff);
        BigDecimal currentQohTotal = mutableInventoryItemState.getQuantityOnHandTotal() == null ?
                BigDecimal.ZERO : mutableInventoryItemState.getQuantityOnHandTotal();
        mutableInventoryItemState.setQuantityOnHandTotal(currentQohTotal.add(qohDiff));

        // Handle availableToPromise
        BigDecimal atpDiff = availableToPromiseDiff == null ? BigDecimal.ZERO : availableToPromiseDiff;
        detailState.setAvailableToPromiseDiff(atpDiff);
        BigDecimal currentAtpTotal = mutableInventoryItemState.getAvailableToPromiseTotal() == null ?
                BigDecimal.ZERO : mutableInventoryItemState.getAvailableToPromiseTotal();
        mutableInventoryItemState.setAvailableToPromiseTotal(currentAtpTotal.add(atpDiff));

        // Handle accountingQuantity
        BigDecimal aqDiff = accountingQuantityDiff == null ? BigDecimal.ZERO : accountingQuantityDiff;
        detailState.setAccountingQuantityDiff(aqDiff);
        BigDecimal currentAqTotal = mutableInventoryItemState.getAccountingQuantityTotal() == null ?
                BigDecimal.ZERO : mutableInventoryItemState.getAccountingQuantityTotal();
        mutableInventoryItemState.setAccountingQuantityTotal(currentAqTotal.add(aqDiff));

        // Unit cost handling is commented out in the original code
        // if (unitCost != null) {
        //     detailState.setUnitCost(unitCost);
        //     mutableInventoryItemState.setUnitCost(unitCost);
        // }

        return mutableInventoryItemState;
    }
}
