// <autogenerated>
//   This file was generated by dddappp code generator.
//   Any changes made to this file manually will be lost next time the file is regenerated.
// </autogenerated>

package org.dddml.ffvtraceability.domain.inventoryitem;

import com.fasterxml.jackson.databind.ObjectMapper;
import org.dddml.ffvtraceability.domain.mapper.InventoryItemMapper;
import org.dddml.ffvtraceability.specialization.DomainError;
import org.dddml.ffvtraceability.specialization.MutationContext;
import org.dddml.ffvtraceability.specialization.VerificationContext;
import org.erdtman.jcs.JsonCanonicalizer;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import org.springframework.util.DigestUtils;

import java.math.BigDecimal;
import java.nio.charset.StandardCharsets;
import java.util.UUID;


/**
 * Implementation of the InventoryItem.RecordInventoryEntry command logic.
 */
@Component("(inventoryItem_RecordInventoryEntry)")
public class RecordInventoryEntryLogic implements IRecordInventoryEntryLogic {

    private static ObjectMapper objectMapper;

    static {
        objectMapper = new com.fasterxml.jackson.databind.ObjectMapper();
        objectMapper.setSerializationInclusion(com.fasterxml.jackson.annotation.JsonInclude.Include.NON_NULL);
        objectMapper.configure(com.fasterxml.jackson.databind.DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false); // 反序列化时忽略未知属性
        objectMapper.registerModule(new com.fasterxml.jackson.datatype.jsr310.JavaTimeModule())
                .setDateFormat(new com.fasterxml.jackson.databind.util.StdDateFormat().withColonInTimeZone(true))
                .configure(com.fasterxml.jackson.databind.SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false)
                .configure(com.fasterxml.jackson.databind.SerializationFeature.WRITE_DATE_TIMESTAMPS_AS_NANOSECONDS, false)
                .configure(com.fasterxml.jackson.databind.DeserializationFeature.ADJUST_DATES_TO_CONTEXT_TIME_ZONE, false);
    }

    @Autowired
    private InventoryItemMapper inventoryItemMapper;

    /**
     * Verifies the InventoryItem.RecordInventoryEntry command by performing validation logic
     * before the state mutation. Creates and returns an event.
     *
     * @param eventFactory                  The supplier that creates new InventoryItemEvent.RecordInventoryEntryEvent events
     * @param inventoryItemState            The current state of the InventoryItem aggregate
     * @param inventoryItemAttributes
     * @param inventoryItemDetailAttributes
     * @param quantityOnHandDiff
     * @param availableToPromiseDiff
     * @param accountingQuantityDiff
     * @param unitCost
     * @param verificationContext           The context information for the verification process
     * @return An event that will be applied to the current state to update the InventoryItem
     */
    public InventoryItemEvent.RecordInventoryEntryEvent verify(
            java.util.function.Supplier<InventoryItemEvent.RecordInventoryEntryEvent> eventFactory,
            InventoryItemState inventoryItemState,
            InventoryItemAttributes inventoryItemAttributes,
            InventoryItemDetailAttributes inventoryItemDetailAttributes,
            java.math.BigDecimal quantityOnHandDiff,
            java.math.BigDecimal availableToPromiseDiff,
            java.math.BigDecimal accountingQuantityDiff,
            java.math.BigDecimal unitCost,
            VerificationContext verificationContext
    ) {
        InventoryItemEvent.RecordInventoryEntryEvent e = eventFactory.get();

        // TODO: verification logic?
        return e;
    }

    private String getInventoryItemId(InventoryItemAttributes inventoryItemAttributes) {
        try {
            String json = objectMapper.writeValueAsString(inventoryItemAttributes);
            JsonCanonicalizer jc = new JsonCanonicalizer(json);
            String encoded = jc.getEncodedString();
            return DigestUtils.md5DigestAsHex(encoded.getBytes(StandardCharsets.UTF_8));
        } catch (Exception e) {
            throw DomainError.named("CannotCalculateInventoryItemId", "Cannot calculate inventory item id");
        }
    }

    private String getInventoryItemDetailId(InventoryItemDetailAttributes inventoryItemDetailAttributes) {
        try {
            String json = objectMapper.writeValueAsString(inventoryItemDetailAttributes);
            JsonCanonicalizer jc = new JsonCanonicalizer(json);
            String encoded = jc.getEncodedString();
            return DigestUtils.md5DigestAsHex(encoded.getBytes(StandardCharsets.UTF_8));
        } catch (Exception e) {
            throw DomainError.named("CannotCalculateInventoryItemDetailId", "Cannot calculate inventory item detail id");
        }
    }


    /**
     * Performs the state mutation operation of InventoryItem.RecordInventoryEntry command.
     *
     * @param inventoryItemState            The current immutable state of the InventoryItem
     * @param inventoryItemAttributes
     * @param inventoryItemDetailAttributes
     * @param quantityOnHandDiff
     * @param availableToPromiseDiff
     * @param accountingQuantityDiff
     * @param unitCost
     * @param mutationContext               The context that provides functionality including creating mutable state
     * @return The new state of the InventoryItem
     */
    public InventoryItemState mutate(
            InventoryItemState inventoryItemState,
            InventoryItemAttributes inventoryItemAttributes,
            InventoryItemDetailAttributes inventoryItemDetailAttributes,
            java.math.BigDecimal quantityOnHandDiff,
            java.math.BigDecimal availableToPromiseDiff,
            java.math.BigDecimal accountingQuantityDiff,
            java.math.BigDecimal unitCost,
            MutationContext<InventoryItemState, InventoryItemState.MutableInventoryItemState> mutationContext
    ) {
        InventoryItemState.MutableInventoryItemState mutableInventoryItemState;
        if (inventoryItemState == null) {
            mutableInventoryItemState = mutationContext.newMutableStateById(getInventoryItemId(inventoryItemAttributes));
        } else {
            mutableInventoryItemState = mutationContext.toMutableState(inventoryItemState);
        }
        if (inventoryItemState == null) { //s.getVersion() == null) {
            // 新建库存项目
            if (inventoryItemAttributes == null) {
                throw DomainError.named("InvalidAttributes", "InventoryItem attributes are required for new inventory item");
            }
            mutableInventoryItemState.setInventoryItemAttributeHash(mutableInventoryItemState.getInventoryItemId());
            inventoryItemMapper.updateInventoryItemState(mutableInventoryItemState, inventoryItemAttributes);

            InventoryItemDetailState.MutableInventoryItemDetailState d =
                    mutableInventoryItemState.getDetails().getOrAddMutableState(getInventoryItemDetailId(inventoryItemDetailAttributes));
            d.setInventoryItemAttributeHash(d.getInventoryItemDetailSeqId());
            // 如果有详细属性，更新它们
            if (inventoryItemDetailAttributes != null) {
                inventoryItemMapper.updateInventoryItemDetailState(d, inventoryItemDetailAttributes);
            }

            d.setQuantityOnHandDiff(quantityOnHandDiff);
            mutableInventoryItemState.setQuantityOnHandTotal(quantityOnHandDiff);
            d.setAvailableToPromiseDiff(availableToPromiseDiff);
            mutableInventoryItemState.setAvailableToPromiseTotal(availableToPromiseDiff);
            d.setAccountingQuantityDiff(accountingQuantityDiff);
            mutableInventoryItemState.setAccountingQuantityTotal(accountingQuantityDiff);
//            d.setUnitCost(unitCost);
//            s.setUnitCost(unitCost);
        } else {
            // 更新已存在的库存项目
            if (inventoryItemAttributes != null) {
                throw DomainError.named("InvalidOperation",
                        "Cannot modify inventory item attributes for existing inventory item");
            }
            // 创建新的库存明细记录
            InventoryItemDetailState.MutableInventoryItemDetailState d = mutableInventoryItemState.getDetails().getOrAddMutableState(UUID.randomUUID().toString());
            if (inventoryItemDetailAttributes != null) {
                inventoryItemMapper.updateInventoryItemDetailState(d, inventoryItemDetailAttributes);
            }

            // 设置数量变化并累加总量
            if (quantityOnHandDiff != null) {
                d.setQuantityOnHandDiff(quantityOnHandDiff);
                java.math.BigDecimal currentTotal = mutableInventoryItemState.getQuantityOnHandTotal() != null ? mutableInventoryItemState.getQuantityOnHandTotal() : BigDecimal.ZERO;
                mutableInventoryItemState.setQuantityOnHandTotal(currentTotal.add(quantityOnHandDiff));
            }
            if (availableToPromiseDiff != null) {
                d.setAvailableToPromiseDiff(availableToPromiseDiff);
                java.math.BigDecimal currentTotal = mutableInventoryItemState.getAvailableToPromiseTotal() != null ? mutableInventoryItemState.getAvailableToPromiseTotal() : BigDecimal.ZERO;
                mutableInventoryItemState.setAvailableToPromiseTotal(currentTotal.add(availableToPromiseDiff));
            }
            if (accountingQuantityDiff != null) {
                d.setAccountingQuantityDiff(accountingQuantityDiff);
                java.math.BigDecimal currentTotal = mutableInventoryItemState.getAccountingQuantityTotal() != null ? mutableInventoryItemState.getAccountingQuantityTotal() : BigDecimal.ZERO;
                mutableInventoryItemState.setAccountingQuantityTotal(currentTotal.add(accountingQuantityDiff));
            }
//            if (unitCost != null) {
//                d.setUnitCost(unitCost);
//                s.setUnitCost(unitCost); // 更新当前单位成本
//            }

        }
        return mutableInventoryItemState;
    }
}
