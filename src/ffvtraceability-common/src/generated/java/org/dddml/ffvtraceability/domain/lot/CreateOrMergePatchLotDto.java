// <autogenerated>
//   This file was generated by dddappp code generator.
//   Any changes made to this file manually will be lost next time the file is regenerated.
// </autogenerated>

package org.dddml.ffvtraceability.domain.lot;

import java.time.OffsetDateTime;
import org.dddml.ffvtraceability.domain.*;

public class CreateOrMergePatchLotDto extends AbstractLotCommandDto implements LotCommand.CreateOrMergePatchLot {

    /**
     * Quantity
     */
    private java.math.BigDecimal quantity;

    public java.math.BigDecimal getQuantity()
    {
        return this.quantity;
    }

    public void setQuantity(java.math.BigDecimal quantity)
    {
        this.quantity = quantity;
    }

    /**
     * Expiration Date
     */
    private OffsetDateTime expirationDate;

    public OffsetDateTime getExpirationDate()
    {
        return this.expirationDate;
    }

    public void setExpirationDate(OffsetDateTime expirationDate)
    {
        this.expirationDate = expirationDate;
    }

    /**
     * Active
     */
    private String active;

    public String getActive()
    {
        return this.active;
    }

    public void setActive(String active)
    {
        this.active = active;
    }

    /**
     * __ Active__
     */
    private Boolean __Active__;

    public Boolean get__Active__()
    {
        return this.__Active__;
    }

    public void set__Active__(Boolean __Active__)
    {
        this.__Active__ = __Active__;
    }


    private CreateOrMergePatchLotIdentificationDto[] lotIdentifications = new CreateOrMergePatchLotIdentificationDto[0];

    public CreateOrMergePatchLotIdentificationDto[] getLotIdentifications()
    {
        return this.lotIdentifications;
    }

    public void setLotIdentifications(CreateOrMergePatchLotIdentificationDto[] lotIdentifications)
    {
        this.lotIdentifications = lotIdentifications;
    }

    private Boolean isPropertyQuantityRemoved;

    public Boolean getIsPropertyQuantityRemoved()
    {
        return this.isPropertyQuantityRemoved;
    }

    public void setIsPropertyQuantityRemoved(Boolean removed)
    {
        this.isPropertyQuantityRemoved = removed;
    }

    private Boolean isPropertyExpirationDateRemoved;

    public Boolean getIsPropertyExpirationDateRemoved()
    {
        return this.isPropertyExpirationDateRemoved;
    }

    public void setIsPropertyExpirationDateRemoved(Boolean removed)
    {
        this.isPropertyExpirationDateRemoved = removed;
    }

    private Boolean isPropertyActiveRemoved;

    public Boolean getIsPropertyActiveRemoved()
    {
        return this.isPropertyActiveRemoved;
    }

    public void setIsPropertyActiveRemoved(Boolean removed)
    {
        this.isPropertyActiveRemoved = removed;
    }

    private Boolean isProperty__Active__Removed;

    public Boolean getIsProperty__Active__Removed()
    {
        return this.isProperty__Active__Removed;
    }

    public void setIsProperty__Active__Removed(Boolean removed)
    {
        this.isProperty__Active__Removed = removed;
    }

    public void copyTo(CreateOrMergePatchLot command)
    {
        ((AbstractLotCommandDto) this).copyTo(command);
        command.setQuantity(this.getQuantity());
        command.setExpirationDate(this.getExpirationDate());
        command.setActive(this.getActive());
        command.set__Active__(this.get__Active__());
    }

    public LotCommand toCommand()
    {
        if (getCommandType() == null) {
            setCommandType(COMMAND_TYPE_MERGE_PATCH);
        }
        if (COMMAND_TYPE_CREATE.equals(getCommandType())) {
            AbstractLotCommand.SimpleCreateLot command = new AbstractLotCommand.SimpleCreateLot();
            copyTo((AbstractLotCommand.AbstractCreateLot) command);
            if (this.getLotIdentifications() != null) {
                for (CreateOrMergePatchLotIdentificationDto cmd : this.getLotIdentifications()) {
                    command.getLotIdentifications().add((LotIdentificationCommand.CreateLotIdentification) cmd.toCommand());
                }
            }
            return command;
        } else if (COMMAND_TYPE_MERGE_PATCH.equals(getCommandType())) {
            AbstractLotCommand.SimpleMergePatchLot command = new AbstractLotCommand.SimpleMergePatchLot();
            copyTo((AbstractLotCommand.SimpleMergePatchLot) command);
            if (this.getLotIdentifications() != null) {
                for (CreateOrMergePatchLotIdentificationDto cmd : this.getLotIdentifications()) {
                    command.getLotIdentificationCommands().add(cmd.toCommand());
                }
            }
            return command;
        } 
        throw new UnsupportedOperationException("Unknown command type:" + getCommandType());
    }


    public LotCommand toSubclass() {
        if (getCommandType() == null) {
            setCommandType(COMMAND_TYPE_MERGE_PATCH);
        }
        if (COMMAND_TYPE_CREATE.equals(getCommandType()) || null == getCommandType()) {
            CreateLotDto command = new CreateLotDto();
            copyTo((CreateLot) command);
            if (this.getLotIdentifications() != null) {
                for (CreateOrMergePatchLotIdentificationDto cmd : this.getLotIdentifications()) {
                    if (cmd.getCommandType() == null) { cmd.setCommandType(COMMAND_TYPE_CREATE); }
                    command.getCreateLotIdentificationCommands().add((LotIdentificationCommand.CreateLotIdentification) cmd.toSubclass());
                }
            }
            return command;
        } else if (COMMAND_TYPE_MERGE_PATCH.equals(getCommandType())) {
            MergePatchLotDto command = new MergePatchLotDto();
            copyTo((MergePatchLot) command);
            if (this.getLotIdentifications() != null) {
                for (CreateOrMergePatchLotIdentificationDto cmd : this.getLotIdentifications()) {
                    command.getLotIdentificationCommands().add(cmd.toSubclass());
                }
            }
            return command;
        } 
        throw new UnsupportedOperationException("Unknown command type:" + getCommandType());
    }

    public void copyTo(CreateLot command)
    {
        copyTo((CreateOrMergePatchLot) command);
    }

    public void copyTo(MergePatchLot command)
    {
        copyTo((CreateOrMergePatchLot) command);
        command.setIsPropertyQuantityRemoved(this.getIsPropertyQuantityRemoved());
        command.setIsPropertyExpirationDateRemoved(this.getIsPropertyExpirationDateRemoved());
        command.setIsPropertyActiveRemoved(this.getIsPropertyActiveRemoved());
        command.setIsProperty__Active__Removed(this.getIsProperty__Active__Removed());
    }

    public static class CreateLotDto extends CreateOrMergePatchLotDto implements LotCommand.CreateLot
    {
        public CreateLotDto() {
            this.commandType = COMMAND_TYPE_CREATE;
        }

        @Override
        public String getCommandType() {
            return COMMAND_TYPE_CREATE;
        }
        public LotCommand.CreateLot toCreateLot()
        {
            return (LotCommand.CreateLot) toCommand();
        }


        @Override
        public CreateLotIdentificationCommandCollection getCreateLotIdentificationCommands() {
            return new CreateLotIdentificationCommandCollection() {
                @Override
                public void add(LotIdentificationCommand.CreateLotIdentification c) {
                    java.util.List<CreateOrMergePatchLotIdentificationDto> list = new java.util.ArrayList<>(java.util.Arrays.asList(getLotIdentifications()));
                    list.add((CreateOrMergePatchLotIdentificationDto) c);
                    setLotIdentifications(list.toArray(new CreateOrMergePatchLotIdentificationDto[0]));
                }

                @Override
                public void remove(LotIdentificationCommand.CreateLotIdentification c) {
                    java.util.List<CreateOrMergePatchLotIdentificationDto> list = new java.util.ArrayList<>(java.util.Arrays.asList(getLotIdentifications()));
                    list.remove((CreateOrMergePatchLotIdentificationDto) c);
                    setLotIdentifications(list.toArray(new CreateOrMergePatchLotIdentificationDto[0]));
                }

                @Override
                public void clear() {
                    setLotIdentifications(new CreateOrMergePatchLotIdentificationDto[]{});
                }

                @Override
                public java.util.Iterator<LotIdentificationCommand.CreateLotIdentification> iterator() {
                    return java.util.Arrays.stream(getLotIdentifications())
                            .map(e -> {if (e.getCommandType()==null) e.setCommandType(COMMAND_TYPE_CREATE);return (LotIdentificationCommand.CreateLotIdentification) e.toSubclass();}).iterator();
                }
            };
        }

        @Override
        public LotIdentificationCommand.CreateLotIdentification newCreateLotIdentification() {
            return new CreateOrMergePatchLotIdentificationDto.CreateLotIdentificationDto();
        }

    }

    public static class MergePatchLotDto extends CreateOrMergePatchLotDto implements LotCommand.MergePatchLot
    {
        public MergePatchLotDto() {
            this.commandType = COMMAND_TYPE_MERGE_PATCH;
        }

        @Override
        public String getCommandType() {
            return COMMAND_TYPE_MERGE_PATCH;
        }
        public LotCommand.MergePatchLot toMergePatchLot()
        {
            return (LotCommand.MergePatchLot) toCommand();
        }


        @Override
        public LotIdentificationCommandCollection getLotIdentificationCommands() {
            return new LotIdentificationCommandCollection() {
                @Override
                public void add(LotIdentificationCommand c) {
                    java.util.List<CreateOrMergePatchLotIdentificationDto> list = new java.util.ArrayList<>(java.util.Arrays.asList(getLotIdentifications()));
                    list.add((CreateOrMergePatchLotIdentificationDto) c);
                    setLotIdentifications(list.toArray(new CreateOrMergePatchLotIdentificationDto[0]));
                }

                @Override
                public void remove(LotIdentificationCommand c) {
                    java.util.List<CreateOrMergePatchLotIdentificationDto> list = new java.util.ArrayList<>(java.util.Arrays.asList(getLotIdentifications()));
                    list.remove((CreateOrMergePatchLotIdentificationDto) c);
                    setLotIdentifications(list.toArray(new CreateOrMergePatchLotIdentificationDto[0]));
                }

                @Override
                public void clear() {
                    setLotIdentifications(new CreateOrMergePatchLotIdentificationDto[]{});
                }

                @Override
                public java.util.Iterator<LotIdentificationCommand> iterator() {
                    return java.util.Arrays.stream(getLotIdentifications())
                            .map(e -> (LotIdentificationCommand) e.toSubclass()).iterator();
                }
            };
        }

        @Override
        public LotIdentificationCommand.CreateLotIdentification newCreateLotIdentification() {
            return new CreateOrMergePatchLotIdentificationDto.CreateLotIdentificationDto();
        }

        @Override
        public LotIdentificationCommand.MergePatchLotIdentification newMergePatchLotIdentification() {
            return new CreateOrMergePatchLotIdentificationDto.MergePatchLotIdentificationDto();
        }

        @Override
        public LotIdentificationCommand.RemoveLotIdentification newRemoveLotIdentification() {
            return new RemoveLotIdentificationDto();
        }

    }

}

