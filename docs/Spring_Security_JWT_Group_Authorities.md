# Spring Security：结合使用 JWT 和 Group Authorities

> 注意：以下内容基于与 AI 对话的结果整理而成，细节上没有经过验证，仅供参考。

本文介绍如何在 Spring Security 中结合使用 JWT（JSON Web Token）认证和 Group Authorities 功能。

## 基础配置

### 1. 添加依赖
首先在 `pom.xml` 中添加必要的依赖：

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-oauth2-resource-server</artifactId>
</dependency>
```

### 2. 数据库表结构
确保数据库中有必要的组权限表（这些是 Spring Security 默认的表结构）：

```sql
create table groups (
    id bigint generated by default as identity(start with 1) primary key,
    group_name varchar(50) not null
);

create table group_authorities (
    group_id bigint not null,
    authority varchar(50) not null,
    constraint fk_group_authorities_group foreign key(group_id) references groups(id)
);

create table group_members (
    id bigint generated by default as identity(start with 1) primary key,
    username varchar(50) not null,
    group_id bigint not null,
    constraint fk_group_members_group foreign key(group_id) references groups(id)
);
```

## 实现方案

### 方案一：将所有权限放入 JWT（简单但可能导致 token 过大）

#### 1. SecurityConfig 配置

```java
@Configuration 
@EnableWebSecurity
public class SecurityConfig {
    
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .csrf(csrf -> csrf.disable())
            .sessionManagement(session -> session
                .sessionCreationPolicy(SessionCreationPolicy.STATELESS))
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/h2-console/**", "/auth/**").permitAll()
                .anyRequest().authenticated())
            .oauth2ResourceServer(oauth2 -> oauth2
                .jwt(Customizer.withDefaults()));

        return http.build();
    }
    
    @Bean
    public UserDetailsService userDetailsService(DataSource dataSource) {
        JdbcUserDetailsManager users = new JdbcUserDetailsManager(dataSource);
        
        // 启用组功能
        users.setEnableGroups(true);
        users.setGroupAuthoritiesByUsernameQuery(
            "select g.id, g.group_name, ga.authority " +
            "from groups g, group_members gm, group_authorities ga " +
            "where gm.username = ? " +
            "and g.id = ga.group_id " +
            "and g.id = gm.group_id"
        );
        
        return users;
    }

    @Bean
    public JwtDecoder jwtDecoder() {
        return NimbusJwtDecoder.withSecretKey(getSecretKey()).build();
    }

    @Bean
    public JwtEncoder jwtEncoder() {
        return new NimbusJwtEncoder(new ImmutableSecret<>(getSecretKey()));
    }

    private SecretKey getSecretKey() {
        byte[] keyBytes = Base64.getDecoder().decode("your-base64-encoded-secret-key");
        return new SecretKeySpec(keyBytes, "HmacSHA256");
    }

    @Bean
    public AuthenticationManager authenticationManager(UserDetailsService userDetailsService,
            PasswordEncoder passwordEncoder) {
        DaoAuthenticationProvider authenticationProvider = new DaoAuthenticationProvider();
        authenticationProvider.setUserDetailsService(userDetailsService);
        authenticationProvider.setPasswordEncoder(passwordEncoder);

        return new ProviderManager(authenticationProvider);
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}
```

#### 2. JWT 认证转换器

```java
@Component
public class CustomJwtAuthenticationConverter implements Converter<Jwt, AbstractAuthenticationToken> {
    
    @Override
    public AbstractAuthenticationToken convert(Jwt jwt) {
        Collection<GrantedAuthority> authorities = extractAuthorities(jwt);
        
        return new JwtAuthenticationToken(jwt, authorities);
    }
    
    @SuppressWarnings("unchecked")
    private Collection<GrantedAuthority> extractAuthorities(Jwt jwt) {
        Collection<String> authorities = (Collection<String>) 
            jwt.getClaims().getOrDefault("authorities", Collections.emptyList());
            
        return authorities.stream()
            .map(SimpleGrantedAuthority::new)
            .collect(Collectors.toList());
    }
}
```

#### 3. 认证控制器

```java
@RestController
@RequestMapping("/auth")
public class AuthController {
    
    @Autowired
    private JwtEncoder encoder;
    
    @Autowired
    private AuthenticationManager authenticationManager;

    @PostMapping("/login")
    public ResponseEntity<String> login(@RequestBody LoginRequest request) {
        // 使用 JdbcUserDetailsManager 进行认证
        Authentication authentication = authenticationManager.authenticate(
            new UsernamePasswordAuthenticationToken(request.getUsername(), request.getPassword())
        );
        
        // 获取所有权限（包括直接权限和组权限）
        Set<String> authorities = authentication.getAuthorities().stream()
            .map(GrantedAuthority::getAuthority)
            .collect(Collectors.toSet());
        
        // 生成JWT，包含用户权限
        Instant now = Instant.now();
        JwtClaimsSet claims = JwtClaimsSet.builder()
            .issuer("self")
            .issuedAt(now)
            .expiresAt(now.plusSeconds(36000L))
            .subject(authentication.getName())
            .claim("authorities", authorities)
            .build();

        String token = encoder.encode(JwtEncoderParameters.from(claims)).getTokenValue();
        return ResponseEntity.ok(token);
    }
}
```

### 方案二：优化 JWT 大小

考虑到将所有权限都放入 JWT claims 中可能会导致令牌变得很大，特别是当用户属于多个组且每个组都有大量权限时，这里提供几种优化方案：

#### 1. 只存储组标识符

```java
@PostMapping("/login")
public ResponseEntity<String> login(@RequestBody LoginRequest request) {
    Authentication authentication = authenticationManager.authenticate(
        new UsernamePasswordAuthenticationToken(request.getUsername(), request.getPassword())
    );
    
    // 只提取用户所属的组名，而不是所有权限
    Set<String> groups = authentication.getAuthorities().stream()
        .map(GrantedAuthority::getAuthority)
        .filter(auth -> auth.startsWith("GROUP_"))  // 只保留组信息
        .collect(Collectors.toSet());
    
    JwtClaimsSet claims = JwtClaimsSet.builder()
        .issuer("self")
        .issuedAt(now)
        .expiresAt(now.plusSeconds(36000L))
        .subject(authentication.getName())
        .claim("groups", groups)  // 只存储组信息
        .build();
    
    return ResponseEntity.ok(encoder.encode(JwtEncoderParameters.from(claims)).getTokenValue());
}
```

#### 2. 使用权限压缩

```java
// 使用更紧凑的格式存储权限
Map<String, Integer> PERMISSION_CODES = Map.of(
    "ROLE_USER", 1,
    "ROLE_ADMIN", 2,
    "ROLE_MANAGER", 3
    // ... 等
);

// 在生成token时压缩权限
List<Integer> compressedAuth = authorities.stream()
    .map(auth -> PERMISSION_CODES.get(auth.getAuthority()))
    .filter(Objects::nonNull)
    .collect(Collectors.toList());
```

#### 3. 采用混合方案

```java
@Component
public class CustomJwtAuthenticationConverter implements Converter<Jwt, AbstractAuthenticationToken> {
    
    @Autowired
    private DataSource dataSource;
    
    @Override
    public AbstractAuthenticationToken convert(Jwt jwt) {
        String username = jwt.getSubject();
        Set<String> groups = (Set<String>) jwt.getClaims().get("groups");
        
        // 需要详细权限时才查询数据库
        Collection<GrantedAuthority> authorities = loadAuthoritiesForGroups(groups);
        
        return new JwtAuthenticationToken(jwt, authorities);
    }
}
```

#### 4. 使用权限缓存

```java
@Component
public class AuthoritiesCache {
    private Cache<String, Set<GrantedAuthority>> cache;
    
    public AuthoritiesCache() {
        this.cache = Caffeine.newBuilder()
            .expireAfterWrite(1, TimeUnit.HOURS)
            .maximumSize(10000)
            .build();
    }
    
    public Set<GrantedAuthority> getAuthorities(String username) {
        return cache.get(username, this::loadAuthoritiesFromDb);
    }
}
```

## 方案选择建议

这些方案各有优劣：
- 方案一最简单，但可能导致token过大
- 方案二的各种优化方案可以显著减小token大小，但增加了复杂性
- 混合方案灵活性最好，但需要权衡性能
- 缓存方案可以平衡性能和token大小，但需要管理缓存

具体选择哪种方案，需要根据实际需求来决定：
- 如果权限数量有限，可以使用方案一
- 如果权限数量庞大，建议考虑优化方案
- 如果性能要求高，可以考虑使用缓存方案

## 配置说明

在 `application.properties` 中添加必要的配置：

```properties
spring.security.oauth2.resourceserver.jwt.secret-key=your-base64-encoded-secret-key
```

## 总结

Spring Security 的 JWT 认证和 Group Authorities 是完全兼容的，它们负责不同的职责：
- JdbcUserDetailsManager 负责用户信息的管理和查询
- JWT 认证则负责生成和验证令牌

选择合适的实现方案时，需要在简单性、性能和可维护性之间找到平衡点。



## 自包含的资源服务器（JWT + Group Authorities）的 SQL 优化

假设已有一个自包含认证授权功能的资源服务器，使用 JWT 和 Group Authorities。

### 基础配置

#### 1. 添加依赖
```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-oauth2-resource-server</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-jdbc</artifactId>
</dependency>
```

#### 2. 配置文件
```properties
# JWT配置
jwt.secret-key=your-base64-encoded-secret-key
jwt.expiration=86400

# 数据源配置（示例使用H2数据库）
spring.datasource.url=jdbc:h2:mem:testdb
spring.datasource.driver-class-name=org.h2.Driver
```

### 核心实现

#### 1. 自定义用户详情服务

```java
@Service
public class CustomUserDetailsService implements UserDetailsService {
    
    @Autowired
    private JdbcTemplate jdbcTemplate;
    
    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        String sql = """
            SELECT u.username, 
                   u.password, 
                   u.enabled,
                   ua.authority as direct_authority,
                   ga.authority as group_authority
            FROM users u
            LEFT JOIN (
                SELECT username, authority 
                FROM user_authorities 
                WHERE username = ?
            ) ua ON u.username = ua.username
            LEFT JOIN (
                SELECT gm.username, ga.authority
                FROM group_members gm
                JOIN group_authorities ga ON gm.group_id = ga.group_id
                WHERE gm.username = ?
            ) ga ON u.username = ga.username
            WHERE u.username = ?
            """;
            
        List<UserAuthority> authorities = jdbcTemplate.query(sql, 
            (rs, rowNum) -> new UserAuthority(
                rs.getString("direct_authority"),
                rs.getString("group_authority")
            ), 
            username, username, username
        );
        
        if (authorities.isEmpty()) {
            throw new UsernameNotFoundException("User not found");
        }
        
        // 合并权限
        Set<GrantedAuthority> mergedAuthorities = authorities.stream()
            .flatMap(auth -> Stream.of(auth.getDirectAuthority(), auth.getGroupAuthority()))
            .filter(StringUtils::hasText)
            .map(SimpleGrantedAuthority::new)
            .collect(Collectors.toSet());
            
        return User.builder()
            .username(username)
            .password(authorities.get(0).getPassword())
            .authorities(mergedAuthorities)
            .build();
    }
}
```

#### 2. Token 服务

```java
@Service
public class TokenService {
    
    @Value("${jwt.secret-key}")
    private String secretKey;
    
    @Value("${jwt.expiration}")
    private Long expiration;
    
    public String generateToken(Authentication authentication) {
        UserDetails userDetails = (UserDetails) authentication.getPrincipal();
        
        Map<String, Object> claims = new HashMap<>();
        claims.put("authorities", userDetails.getAuthorities().stream()
            .map(GrantedAuthority::getAuthority)
            .collect(Collectors.toList()));
            
        return Jwts.builder()
            .setClaims(claims)
            .setSubject(userDetails.getUsername())
            .setIssuedAt(new Date())
            .setExpiration(new Date(System.currentTimeMillis() + expiration * 1000))
            .signWith(Keys.hmacShaKeyFor(secretKey.getBytes()))
            .compact();
    }
}
```

#### 3. 认证控制器

```java
@RestController
@RequestMapping("/auth")
public class AuthController {
    
    @Autowired
    private AuthenticationManager authenticationManager;
    
    @Autowired
    private TokenService tokenService;
    
    @PostMapping("/login")
    public ResponseEntity<String> login(@RequestBody LoginRequest request) {
        Authentication authentication = authenticationManager.authenticate(
            new UsernamePasswordAuthenticationToken(request.getUsername(), request.getPassword())
        );
        
        String token = tokenService.generateToken(authentication);
        return ResponseEntity.ok(token);
    }
}
```

#### 4. 安全配置

```java
@Configuration 
@EnableWebSecurity
public class SecurityConfig {
    
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .csrf(csrf -> csrf.disable())
            .sessionManagement(session -> session
                .sessionCreationPolicy(SessionCreationPolicy.STATELESS))
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/auth/**").permitAll()
                .anyRequest().authenticated())
            .oauth2ResourceServer(oauth2 -> oauth2
                .jwt(Customizer.withDefaults()));

        return http.build();
    }

    @Bean
    public AuthenticationManager authenticationManager(
            UserDetailsService userDetailsService,
            PasswordEncoder passwordEncoder) {
        DaoAuthenticationProvider provider = new DaoAuthenticationProvider();
        provider.setUserDetailsService(userDetailsService);
        provider.setPasswordEncoder(passwordEncoder);
        return new ProviderManager(provider);
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}
```

### 优势特点

1. **高效的权限查询**：
   - 使用优化的SQL一次性获取所有权限信息
   - 减少数据库查询次数
   - 支持标准数据库（H2, PostgreSQL等）

2. **自包含认证**：
   - 不依赖外部认证服务器
   - JWT中包含完整的用户权限信息
   - 支持直接权限和组权限的混合使用

3. **灵活的权限管理**：
   - 支持直接给用户分配权限
   - 支持通过组分配权限
   - 权限信息实时生效

### 使用说明

1. **配置数据库**：
   - 创建必要的数据库表
   - 插入用户、组和权限数据

2. **获取令牌**：
```http
POST /auth/login
Content-Type: application/json

{
    "username": "user",
    "password": "password"
}
```

3. **使用令牌**：
```http
GET /api/resource
Authorization: Bearer <token>
```

### 注意事项

1. 确保 JWT 密钥的安全性
2. 合理设置 token 过期时间
3. 根据实际需求调整权限查询SQL
4. 考虑添加权限缓存机制（可选）


### 优化 JWT 中的权限结构

在 JWT 中清晰地区分直接权限和组权限，使权限结构更加合理。

#### 核心实现

##### 1. Token 服务
```java
@Service
public class TokenService {
    
    @Value("${jwt.secret-key}")
    private String secretKey;
    
    @Value("${jwt.expiration}")
    private Long expiration;
    
    public String generateToken(Authentication authentication) {
        UserDetails userDetails = (UserDetails) authentication.getPrincipal();
        
        // 假设我们已经在 UserDetails 中区分了直接权限和组权限
        CustomUserDetails customUserDetails = (CustomUserDetails) userDetails;
        
        Map<String, Object> claims = new HashMap<>();
        claims.put("directAuthorities", customUserDetails.getDirectAuthorities());
        claims.put("groups", customUserDetails.getGroups());
            
        return Jwts.builder()
            .setClaims(claims)
            .setSubject(userDetails.getUsername())
            .setIssuedAt(new Date())
            .setExpiration(new Date(System.currentTimeMillis() + expiration * 1000))
            .signWith(Keys.hmacShaKeyFor(secretKey.getBytes()))
            .compact();
    }
}
```

##### 2. 自定义用户详情类
```java
public class CustomUserDetails extends User {
    private final Set<String> directAuthorities;
    private final Set<String> groups;
    
    public CustomUserDetails(String username, String password, 
            Set<String> directAuthorities, Set<String> groups) {
        super(username, password, 
              Stream.concat(directAuthorities.stream(), groups.stream())
                    .map(SimpleGrantedAuthority::new)
                    .collect(Collectors.toSet()));
        this.directAuthorities = directAuthorities;
        this.groups = groups;
    }
    
    public Set<String> getDirectAuthorities() {
        return directAuthorities;
    }
    
    public Set<String> getGroups() {
        return groups;
    }
}
```

##### 3. 自定义用户详情服务
```java
@Service
public class CustomUserDetailsService implements UserDetailsService {
    
    @Autowired
    private JdbcTemplate jdbcTemplate;
    
    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        String sql = """
            SELECT u.username, 
                   u.password, 
                   u.enabled,
                   ua.authority as direct_authority,
                   g.group_name as group_name
            FROM users u
            LEFT JOIN (
                SELECT username, authority 
                FROM user_authorities 
                WHERE username = ?
            ) ua ON u.username = ua.username
            LEFT JOIN (
                SELECT gm.username, g.group_name
                FROM group_members gm
                JOIN groups g ON gm.group_id = g.group_id
                WHERE gm.username = ?
            ) g ON u.username = g.username
            WHERE u.username = ?
            """;
            
        List<UserAuthorityDto> results = jdbcTemplate.query(sql, 
            (rs, rowNum) -> new UserAuthorityDto(
                rs.getString("username"),
                rs.getString("password"),
                rs.getBoolean("enabled"),
                rs.getString("direct_authority"),
                rs.getString("group_name")
            ), 
            username, username, username
        );
        
        if (results.isEmpty()) {
            throw new UsernameNotFoundException("User not found");
        }
        
        // 收集直接权限和组
        Set<String> directAuthorities = results.stream()
            .map(UserAuthorityDto::getDirectAuthority)
            .filter(StringUtils::hasText)
            .collect(Collectors.toSet());
            
        Set<String> groups = results.stream()
            .map(UserAuthorityDto::getGroupName)
            .filter(StringUtils::hasText)
            .map(group -> "GROUP_" + group)  // 添加GROUP_前缀
            .collect(Collectors.toSet());
            
        return new CustomUserDetails(
            results.get(0).getUsername(),
            results.get(0).getPassword(),
            directAuthorities,
            groups
        );
    }
}
```

##### 4. JWT 认证转换器
```java
@Component
public class CustomJwtAuthenticationConverter implements Converter<Jwt, AbstractAuthenticationToken> {
    
    @Override
    public AbstractAuthenticationToken convert(Jwt jwt) {
        Set<GrantedAuthority> authorities = new HashSet<>();
        
        // 添加直接权限
        getClaimAsSet(jwt, "directAuthorities")
            .stream()
            .map(SimpleGrantedAuthority::new)
            .forEach(authorities::add);
            
        // 添加组权限
        getClaimAsSet(jwt, "groups")
            .stream()
            .map(SimpleGrantedAuthority::new)
            .forEach(authorities::add);
        
        return new JwtAuthenticationToken(jwt, authorities);
    }
    
    @SuppressWarnings("unchecked")
    private Set<String> getClaimAsSet(Jwt jwt, String claimName) {
        Object claim = jwt.getClaims().get(claimName);
        if (claim instanceof Collection) {
            return new HashSet<>((Collection<String>) claim);
        }
        return Collections.emptySet();
    }
}
```

#### 改进说明

这种实现方式带来以下改进：

1. **清晰的权限结构**
   - JWT 中明确区分直接权限和组权限
   - 用户详情服务直接查询组名而不是组权限
   - 认证转换器分别处理两种权限

2. **优化的数据查询**
   - 使用优化的 SQL 一次性获取所有信息
   - 直接获取组名而不是组权限
   - 支持标准数据库（H2, PostgreSQL等）

3. **更好的可维护性**
   - 权限结构更清晰
   - 便于后续扩展（如添加组权限缓存）
   - 更容易进行权限追踪和审计
   - JWT 的结构更加合理

4. **灵活的权限管理**
   - 可以单独管理直接权限
   - 可以通过组统一管理权限
   - 支持权限的动态调整

#### JWT 结构示例

生成的 JWT payload 示例：
```json
{
  "sub": "user123",
  "directAuthorities": [
    "ROLE_USER",
    "READ_PROFILE"
  ],
  "groups": [
    "GROUP_ADMIN",
    "GROUP_MANAGER"
  ],
  "iat": 1516239022,
  "exp": 1516247022
}
```

### 资源服务器的 JWT 权限转换实现

在资源服务器端，我们需要从 JWT 中的组信息恢复出实际的权限，以支持标准的 `hasAuthority` 注解。

#### 核心实现

##### JWT 认证转换器
```java
@Component
public class ResourceServerJwtAuthenticationConverter implements Converter<Jwt, AbstractAuthenticationToken> {
    
    @Autowired
    private JdbcTemplate jdbcTemplate;
    
    @Autowired
    private LoadingCache<String, Set<String>> groupAuthoritiesCache;
    
    @Override
    public AbstractAuthenticationToken convert(Jwt jwt) {
        Set<GrantedAuthority> authorities = new HashSet<>();
        
        // 1. 添加直接权限
        getClaimAsSet(jwt, "directAuthorities")
            .stream()
            .map(SimpleGrantedAuthority::new)
            .forEach(authorities::add);
            
        // 2. 从组恢复权限
        getClaimAsSet(jwt, "groups")
            .stream()
            .map(this::getGroupAuthorities)  // 获取组对应的权限
            .flatMap(Set::stream)
            .map(SimpleGrantedAuthority::new)
            .forEach(authorities::add);
        
        return new JwtAuthenticationToken(jwt, authorities);
    }
    
    @SuppressWarnings("unchecked")
    private Set<String> getClaimAsSet(Jwt jwt, String claimName) {
        Object claim = jwt.getClaims().get(claimName);
        if (claim instanceof Collection) {
            return new HashSet<>((Collection<String>) claim);
        }
        return Collections.emptySet();
    }
    
    private Set<String> getGroupAuthorities(String groupName) {
        try {
            return groupAuthoritiesCache.get(groupName);
        } catch (ExecutionException e) {
            throw new RuntimeException("Failed to load group authorities", e);
        }
    }
}
```

##### 组权限缓存配置
```java
@Configuration
public class GroupAuthoritiesCacheConfig {
    
    @Autowired
    private JdbcTemplate jdbcTemplate;
    
    @Bean
    public LoadingCache<String, Set<String>> groupAuthoritiesCache() {
        return Caffeine.newBuilder()
            .expireAfterWrite(1, TimeUnit.HOURS)
            .maximumSize(1000)
            .build(this::loadGroupAuthorities);
    }
    
    private Set<String> loadGroupAuthorities(String groupName) {
        String sql = """
            SELECT authority 
            FROM group_authorities ga 
            JOIN groups g ON ga.group_id = g.id 
            WHERE g.group_name = ?
            """;
            
        return new HashSet<>(jdbcTemplate.queryForList(sql, String.class, 
            groupName.replace("GROUP_", "")));  // 移除GROUP_前缀
    }
}
```

##### 资源服务器配置
```java
@Configuration
@EnableWebSecurity
public class ResourceServerConfig {

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .csrf(csrf -> csrf.disable())
            .sessionManagement(session -> session
                .sessionCreationPolicy(SessionCreationPolicy.STATELESS))
            .authorizeHttpRequests(auth -> auth
                .anyRequest().authenticated())
            .oauth2ResourceServer(oauth2 -> oauth2
                .jwt(jwt -> jwt
                    .jwtAuthenticationConverter(resourceServerJwtAuthenticationConverter())));

        return http.build();
    }
    
    @Bean
    public Converter<Jwt, AbstractAuthenticationToken> resourceServerJwtAuthenticationConverter() {
        return new ResourceServerJwtAuthenticationConverter();
    }
}
```

#### 工作原理

1. JWT 中包含两类信息：
   - `directAuthorities`：用户直接拥有的权限
   - `groups`：用户所属的组

2. 资源服务器处理流程：
   - 直接使用 JWT 中的直接权限
   - 通过缓存从数据库加载组对应的权限
   - 合并所有权限用于授权决策

3. 缓存机制：
   - 使用 Caffeine 缓存组权限
   - 缓存时间为1小时
   - 最大缓存1000个组的权限

#### 优势特点

1. **性能优化**：
   - 使用缓存减少数据库查询
   - 只在需要时加载组权限
   - 支持大规模部署

2. **完整支持**：
   - 支持标准的 `@PreAuthorize` 注解
   - 完整支持组权限
   - 保持与 Spring Security 的兼容性

3. **可维护性**：
   - 清晰的代码结构
   - 易于调试和监控
   - 支持权限的动态更新

#### 使用示例

```java
@RestController
@RequestMapping("/api")
public class ResourceController {
    
    @GetMapping("/resource")
    @PreAuthorize("hasAuthority('READ_RESOURCE')")
    public String getResource() {
        return "Protected Resource";
    }
}
```

在上面的示例中，无论 `READ_RESOURCE` 权限是来自用户的直接权限还是通过组继承的权限，都能正确进行授权判断。

