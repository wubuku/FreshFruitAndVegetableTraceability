# 实体模型设计（草稿）


Tips：

- 模型设计可部分参考 WMS 代码库的分支：`rfid-demo-1`。
  - 该分支 2019 年时为了做“追溯项目”的前期 demo 做过较多有针对性的修改（相对青岛 WMS 系统）。
  - 继续将 WMS 之前的 `AttributeSet` / `AttributeSetInstance` 的设计引入追溯项目——但是会做一些重要的改进。

- 关于 Order 和 Shipment（包括收货类型的 Shipment）之间的关系，参考模型：
  - 《使用 DSL 实现领域驱动设计》- 第四部分 - 数据建模示例：订单的装运与支付；

- 关于业务实体相关模型的设计原则：
  - 《使用 DSL 实现领域驱动设计》- 第四部分 - 不要用“我”的视角去设计核心模型。

- QA 相关模型的设计。
  - 参考 AI 推荐的模型，但是做一些简化。比如，检验方案（scheme）这个阶段似乎没有必要。可以考虑使用：检验单、检验行（InspectionItem）、检查项目（CheckItem）。
  - 将“检验单”主要关联到产品和批次号。（与其他实体的关联的“外键”都允许为空。）


## 处理“编码缺失”

对于作业中可能存在“编码缺失”情况的实体——也就是可能无法获取“标准化”的“领域 ID”的实体：
- 应用给予“内部编码”，作为实体的 Id（key）先保存到数据库中。
- 通过附加的 `XxxIdentification` 实体来实现“编码映射”。
  - 可以通过事后“补录”编码映射的方式来实现“标准化”。
  - 在存在“标准化”的编码映射时，前端显示“标准化”的编码，否则显示“内部编码”。
- 下面讨论了一些例子：
  - `Product` / `GoodIdentification`；
  - `Lot` / `LotIdentification`；
  - `Party` / `PartyIdentification`;
  - `Facility` / `FacilityIdentification` 等。


## 不完整总结：追溯系统可能用到的实体

### 业务主体相关 / 供应商管理

* Party
* PartyRole
* PartyIdentification


### 产品相关 / 原材料管理

* Product
* ProductCategory
* ProductCategoryMember
* GoodIdentification
* Uom
* ShipmentBoxType


装运包装类型实体定义（DDDML 描述）：

```yaml
  ShipmentBoxType:
    id:
      name: ShipmentBoxTypeId
      type: id
    properties:
      Description:
        type: description
      DimensionUomId:
        type: id
      BoxLength:
        type: fixed-point
      BoxWidth:
        type: fixed-point
      BoxHeight:
        type: fixed-point
      WeightUomId:
        type: id
      BoxWeight:
        type: fixed-point
```


### 设施 / 仓库管理

* Facility
* FacilityLocation
* FacilityContactMech

在我们的系统中，“设施”和相关模型一直就是存在的，“仓库”是设施的一种。
设施还有其他类型，比如工厂、农场等。

很显然，一个业务实体可以拥有多个设施。所以设施这个概念和业务实体（在我们的系统中命名为 Party，包括法人、自然人等）是不同的。

> 顺便说一下，供应商、客户，在我们的模型中都是业务实体可扮演的业务“角色”。

#### 设施管理的 UI 设计

目前我们的设计仅包含“仓库管理”界面，但这似乎不够全面。建议设计一个更完整的“设施管理”界面。

> 关于是否将“设施管理”和“仓库管理”界面分开实现的问题：从后端模型的角度来看并不会造成困扰，因为我们的后端模型已经将工厂、农场、仓库等不同类型的设施统一抽象到“设施”（Facility）这个实体中。

#### 为什么需要设施管理？

我们的系统允许用户在没有采购订单（PO）和预先发货通知（ASN）的情况下直接进行收货操作。这种情况下，将“设施”作为基础数据来维护就变得非常必要，因为这可以大大减少用户在现场作业时需要手动录入的信息量。

让我们看看收货事件（ReceivingEvent）需要记录的信息（以下是使用 DDDML 描述的模型）：

```yaml
  ReceivingEvent:
    id:
      name: EventId
      type: CteEventId
    properties:
      TraceabilityLotCode:
        type: KdeTraceabilityLotCode
        description: "Traceability Lot Code"
      QuantityAndUom:
        type: KdeQuantityAndUom
        description: "Quantity and UOM"
      ProductDescription:
        type: KdeProductDescription
        description: "Product Description"
      ShipToLocation:
        type: KdeLocationDescription
        description: "Ship To Location"
        columnNames:
          - ship_to_business_name
          - ship_to_phone_number
          - ship_to_physical_location_address
          - ship_to_city
          - ship_to_state
          - ship_to_zip_code
      ShipFromLocation:
        type: KdeLocationDescription
        description: "Ship From Location"
        columnNames:
          - ship_from_business_name
          - ship_from_phone_number
          - ship_from_physical_location_address
          - ship_from_city
          - ship_from_state
          - ship_from_zip_code
      ReceiveDate:
        type: KdeDate
        description: "Receive Date"
      TlcSourceOrTlcSourceReference:
        type: KdeTlcSourceOrTlcSourceReference
        description: "TLC Source or TLC Source Reference"
        columnNames:
          - tlc_source_business_name
          - tlc_source_phone_number
          - tlc_source_physical_location_address
          - tlc_source_city
          - tlc_source_state
          - tlc_source_zip_code
          - tlc_source_reference_web_site
          - tlc_source_reference_fda_ffrn
          - tlc_source_reference_gln
          - tlc_source_reference_ggn
```

在 ReceivingEvent 中，我们需要记录三个“地点”（设施）相关的信息：

- 发货地（Ship From Location）
- 收货地（Ship To Location）
- 来源地（TLC Source or TLC Source Reference）

其中：
- 来源地信息可以在具备“往前追溯”条件时自动填充
- 收货地即用户登录 App 后选择的“当前仓库”，这部分我们已经完成设计
- 发货地则需要特别关注。虽然我们已经实现了“供应商联系地址”的相关接口，但“供应商联系地址”和“发货地”是两个不同的概念。例如，一个供应商可能拥有多个农场。

因此，我们建议：
1. 在“收货”界面中增加“发货地”的选择功能
2. 将发货地（或称“发货设施”）预先在系统中维护好，并与“供应商”建立关联

虽然这样的设计看起来增加了模型的复杂度，但在 UI/UX 层面我们可以做到对用户友好。比如，当用户在收货操作时选择供应商后：
- 如果该供应商只关联了一个设施，系统可以自动填充“发货地”信息
- 同时可以提供适当的提示，允许用户根据需要新增“发货地”


当前的 UI 设计试图将“设施”这个概念隐藏起来，可能意图是减少需要用户理解的概念的数量。但这个做法可能值得商榷。

因为这个概念其实在这个行业中是一个相当重要的概念：

> 按美国现代食品安全法案要求，生产/加工、包装或储藏在美国消费的人类食品或动物饲料的国内或国外设施的所有者、经营者或负责的代理商或由他们授权的个人，必须向 FDA 注册其设施。（显然一个企业可能拥有多个需要注册的设施。）

我们有必要将“设施”这个概念（实体）暴露给用户。如果缺少了这个概念，那么像 FFRN（设施的注册编号）这样的信息就无处可去（没法找到一个合适的实体去持有它）。

当前设计的最小化的修改建议：供应商的“发货地”的维护界面改为“设施”的维护界面，除了现在的地址/联系方式字段，最少还应该允许用户维护设施的 FFRN 和名称信息。（现在的“发货地”界面中显示的“Address 1”、“Address 2”这样的行项标签可以被设施名称取代。）


### 订单相关 / 采购订单管理

* Order
* OrderItem


### 装运相关 / 收货（Receiving）管理

装运相关实体模型：

* Shipment
* ShipmentItem
* ShipmentReceipt
* Document


### 库存相关 / 产品（托盘等）标签管理

* InventoryItem
* InventoryItemEntry（or InventoryItemDetail）
* AttributeSet
* AttributeSetInstance
* Lot

### QA / 质量管理

* QaInspection
* QaInspectionItem
* QaCheckItem

### 文档 / 文件管理

* Document


### 用户认证 / 授权相关

在 Spring Security 以及 Spring Authorization Server 的基础上进行改进。
默认的 Schema（见本文末尾）可能不能完全满足这些需求，需要做一些改进：

- 首次登录后必须修改密码
- 密码有效期 3 个月，超期自动提醒更改
- ~~冻结用户（似乎可以用 enable 列）~~

基于 Spring Authorization Server 开发一个独立的 OAuth Service 来给用户进行认证和授权（基于 JWT）。

其他后端服务依赖 Spring Authorization Server 的 Resource Server 包来解析和验证 JWT。


### CTE / KDE 相关

见代码库的 dddml 目录中的已有模型（这些模型是 DDDML 描述的 DDD 风格的 OO 模型）。


---

以下是对参考实体模型（主要来自于 OFBiz 与 WMS）的分析：


## InventoryItem 实体

OFBiz 的 InventoryItem 模型定义（OFBiz 的模型是“实体-关系”模型）：

```xml
    <entity entity-name="InventoryItem"
            package-name="org.apache.ofbiz.product.inventory"
            title="Inventory Item">
      <field name="inventoryItemId" type="id"></field>
      <field name="inventoryItemTypeId" type="id"></field>
      <field name="productId" type="id"></field>
      <field name="partyId" type="id"></field>
      <field name="ownerPartyId" type="id"><description>The owner of the inventory item.</description></field>
      <field name="statusId" type="id"></field>
      <field name="datetimeReceived" type="date-time"></field>
      <field name="datetimeManufactured" type="date-time"></field>
      <field name="expireDate" type="date-time"></field>
      <field name="facilityId" type="id"></field>
      <field name="containerId" type="id"></field>
      <field name="lotId" type="id"></field>
      <field name="uomId" type="id"></field>
      <field name="binNumber" type="id"></field>
      <field name="locationSeqId" type="id"></field>
      <field name="comments" type="comment"></field>
      <field name="quantityOnHandTotal" type="fixed-point"></field>
      <field name="availableToPromiseTotal" type="fixed-point"></field>
      <field name="accountingQuantityTotal" type="fixed-point"></field>
      <field name="serialNumber" type="value"></field>
      <field name="softIdentifier" type="value"></field>
      <field name="activationNumber" type="value"></field>
      <field name="activationValidThru" type="date-time"></field>
      <field name="unitCost" type="fixed-point"><description>Higher precision in case it is a calculated number</description></field>
      <field name="currencyUomId" type="id"><description>The currency Uom of the unit cost.</description></field>
      <field name="fixedAssetId" type="id"></field>
      <prim-key field="inventoryItemId"/>
      <relation type="one" fk-name="INV_ITEM_TYPE" rel-entity-name="InventoryItemType">
        <key-map field-name="inventoryItemTypeId"/>
      </relation>
      <relation type="many" rel-entity-name="InventoryItemTypeAttr">
        <key-map field-name="inventoryItemTypeId"/>
      </relation>
      <relation type="one" fk-name="INV_ITEM_CONTAINER" rel-entity-name="Container">
        <key-map field-name="containerId"/>
      </relation>
      <relation type="one" fk-name="INV_ITEM_LOT" rel-entity-name="Lot">
        <key-map field-name="lotId"/>
      </relation>
      <relation type="one-nofk" rel-entity-name="ProductFacility">
        <key-map field-name="productId"/>
        <key-map field-name="facilityId"/>
      </relation>
      <relation type="one-nofk" rel-entity-name="FacilityLocation">
        <key-map field-name="facilityId"/>
        <key-map field-name="locationSeqId"/>
      </relation>
      <relation type="one-nofk" rel-entity-name="ProductFacilityLocation">
        <key-map field-name="productId"/>
        <key-map field-name="facilityId"/>
        <key-map field-name="locationSeqId"/>
      </relation>
      <relation type="one" fk-name="IYIM_FAST" title="FixedAsset" rel-entity-name="FixedAsset">
        <key-map field-name="fixedAssetId"/>
      </relation>
      <!-- 其他关系略 -->
      <index name="INVITEM_SOFID" unique="true">
        <index-field name="softIdentifier"/>
      </index>
      <index name="INVITEM_ACTNM" unique="true">
        <index-field name="activationNumber"/>
      </index>
      <index name="INV_ITEM_SN">
        <index-field name="serialNumber"/>
      </index>
    </entity>
```

InventoryItem 是库存项目实体，用于跟踪和管理仓库中的具体库存项目。让我们详细分析每个字段：

### 1. 基本标识字段

- `inventoryItemId`: 库存项目的唯一标识符
- `inventoryItemTypeId`: 库存项目类型标识符（如：成品、原材料、在制品等）
- `productId`: 关联的产品标识符
- `serialNumber`: 序列号，用于唯一标识特定的产品实例
- `softIdentifier`: 软标识符，可用于额外的产品识别信息
- `binNumber`: 库位号，表示货物在仓库中的具体存放位置

### 2. 组织和所有权字段

- `partyId`: 相关方ID（可能是供应商、客户等）
- `ownerPartyId`: 库存项目的所有者ID
  - 描述：`The owner of the inventory item`
  - 在寄售、代销等业务场景中特别重要

### 3. 位置和存储信息

- `facilityId`: 仓储设施ID（仓库标识）
- `containerId`: 容器ID（如：托盘、箱子等）
- `locationSeqId`: 位置序列ID（具体货架位置）
- `lotId`: 批次ID，用于批次管理和追踪

### 4. 数量相关字段

- `quantityOnHandTotal`: 实际库存总量
- `availableToPromiseTotal`: 可承诺数量总计
  - 表示可以用于销售或承诺给客户的数量
  - 通常小于或等于实际库存量
- `accountingQuantityTotal`: 会计核算数量总计
- `uomId`: 计量单位ID（如：个、箱、千克等）

### 5. 时间相关字段

- `datetimeReceived`: 接收时间
- `datetimeManufactured`: 生产制造时间
- `expireDate`: 过期日期
- `activationValidThru`: 激活有效期

### 6. 成本和货币字段

- `unitCost`: 单位成本
  - 描述：`Higher precision in case it is a calculated number`
  - 使用高精度以支持计算值
- `currencyUomId`: 货币单位ID
  - 描述：`The currency Uom of the unit cost`
  - 用于标识单位成本的货币类型

### 7. 状态和追踪字段

- `statusId`: 状态ID（如：可用、已预留、已报废等）
- `activationNumber`: 激活号码
- `fixedAssetId`: 固定资产ID
- `comments`: 备注信息

### 8. 业务应用场景

1. **库存管理**
   - 通过 `quantityOnHandTotal` 和 `availableToPromiseTotal` 进行库存控制
   - 使用 `lotId` 和 `serialNumber` 进行批次和序列号管理

2. **仓储操作**
   - 利用 `facilityId`、`containerId` 和 `locationSeqId` 进行仓储定位
   - 通过 `binNumber` 实现精确的库位管理

3. **效期管理**
   - 使用 `expireDate` 进行产品效期管理
   - 结合 `datetimeManufactured` 追踪产品生命周期

4. **成本核算**
   - 通过 `unitCost` 和 `currencyUomId` 进行成本管理
   - 使用 `accountingQuantityTotal` 支持财务核算

5. **所有权管理**
   - 通过 `ownerPartyId` 和 `partyId` 管理库存所有权
   - 支持寄售、代销等特殊业务模式

### 9. 注意事项

1. **数量字段管理**
   - 需要确保 `quantityOnHandTotal` ≥ `availableToPromiseTotal`
   - `accountingQuantityTotal` 应与实际库存量保持一致

2. **位置信息完整性**
   - `facilityId`、`locationSeqId` 和 `binNumber` 应形成完整的位置信息链
   - 确保位置信息的准确性和可追溯性

3. **时间字段维护**
   - 及时更新 `datetimeReceived` 和 `datetimeManufactured`
   - 定期检查 `expireDate` 以进行库存效期管理

---

在 OFBiz 中，InventoryItem 实体的数量属性包括：

* `quantityOnHandTotal`。在库数量。
* `availableToPromiseTotal`。可承诺数量。（可销售数量、可发货数量）
* `accountingQuantityTotal`。会计核算数量。


在之前的 WMS 中，InventoryItem 实体的数量属性包括：

```yaml
        # 在库数量
        OnHandQuantity:
          type: decimal
        # 在途数量
        InTransitQuantity:
          type: decimal
        # 保留数量
        ReservedQuantity:
          type: decimal
        # 占用数量
        OccupiedQuantity:
          type: decimal
        # 虚拟数量
        VirtualQuantity:
          type: decimal
```

### InventoryItem 实体的“数量”属性的命名问题

##### OFBiz 的命名方式
- `quantityOnHandTotal`（在库数量）
- `availableToPromiseTotal`（可承诺数量）
- `accountingQuantityTotal`（会计核算数量）

##### 原 WMS 的命名方式

```yaml
        # 在库数量
        OnHandQuantity:
          type: decimal
        # 在途数量
        InTransitQuantity:
          type: decimal
        # 保留数量
        ReservedQuantity:
          type: decimal
        # 占用数量
        OccupiedQuantity:
          type: decimal
        # 虚拟数量
        VirtualQuantity:
          type: decimal
```

理论上，这样做是最自然的：

1. 对于形容词/分词修饰的情况，应该使用“形容词+quantity”的形式
2. 对于介词短语修饰的情况，应该使用“quantity+介词短语”的形式

这样的命名规则更符合英语的语言习惯，也更容易理解和记忆。

##### 针对 WMS 的处理

但是关于 WMS 的 YAML 定义，似乎修改为“统一的形式”更合适：

```yaml
        # 在库数量
        quantityOnHand:
          type: decimal
        # 在途数量
        quantityInTransit:
          type: decimal
        # 保留数量
        quantityReserved:
          type: decimal
        # 占用数量
        quantityOccupied:
          type: decimal
        # 虚拟数量
        quantityVirtual:
          type: decimal
```

### 对 WMS InventoryItem 实体 Id 的改进考虑

当前的 InventoryItem 实体的“领域 ID”的类型为：

```yaml
        InventoryItemId:
          properties:
            # 产品 Id
            ProductId:
              type: id-long
              columnName: ProductId
              length: 60
            # 货位 Id.
            LocatorId: 
              type: string
              columnName: LocatorId
              length: 50
            # 属性集实例 Id.
            AttributeSetInstanceId:
              type: string
              columnName: AttributeSetInstanceId
              length: 50
```

如果想要更“偏向”OFBiz 的实体模型的设计，可以考虑改为：

```yaml
        InventoryItemId:
          properties:
            ProductId:
              type: id-long
            # 考虑弃用 Locator 实体，改为使用 Facility 与 FacilityLocation 实体
            FacilityId:
              type: id
            LocationSeqId:
              type: id
            AttributeSetInstanceId:
              type: id-long
              #c1913514d984b1e2839bea485ed5a3ec
```

这样做的好处是：可以更多地“直接利用”OFBiz 的 Facility 实体和 FacilityLocation 实体的设计。

除了领域 Id（复合 ID）之外的其他 OFBiz 库存单元的属性，比如 `fixedAssetId`、`lotId`、`serialNumber`、`softIdentifier`、`activationNumber` 等，
都可以考虑放到 AttributeSetInstance 实体中。

### 对 AttributeSetInstance 的改进考虑

我们可以考虑将 `AttributeSetInstance` 实现为一个 `Map<String, Object>`，数据库的持久化类型为 `JSONB` 或者 `JSON`，可以充分满足可扩展性的要求。

这也是为什么我们建议使用 PostgreSQL 数据库的原因之一。因为 PostgreSQL 对 JSONB/JSON 列类型的支持是比较好的。

给 AttributeSetInstance 预先定义一些 Key（或者说 AttributeId）常量。
这些 Key 支持“可配置”，前端可以显示这些 Key 的“描述”；后端对 Key / Value 的合法性进行检查。
比如：

* CaseGTIN:
  * description: "AI (01) Case GTIN"
* CaseBatch:
  * description: "AI (10) Case Batch/Lot"
* PalletSSCC:
  * description: "AI (00) Pallet SSCC"
* PackDate:
  * description: "AI (13) Pack Date"
* HarvestDate:
  * description: "AI (13) Harvest Date"
* BestIfUsedByDate:
  * description: "AI (15) Best if Used by Date"
* SerialNumber:
  * description: "AI (21) Serial Number"

考虑 Attribute 支持更多的“类型”，比如似乎有必要支持 OffsetDateTime 等。


## InventoryItemDetail 实体

OFBiz 的 InventoryItemDetail 实体定义：

```xml
    <entity entity-name="InventoryItemDetail"
            package-name="org.apache.ofbiz.product.inventory"
            title="Inventory Item Detail">
      <field name="inventoryItemId" type="id"></field>
      <field name="inventoryItemDetailSeqId" type="id"></field>
      <field name="effectiveDate" type="date-time"></field>
      <field name="quantityOnHandDiff" type="fixed-point"></field>
      <field name="availableToPromiseDiff" type="fixed-point"></field>
      <field name="accountingQuantityDiff" type="fixed-point"></field>
      <field name="unitCost" type="fixed-point"></field>
      <field name="orderId" type="id"></field>
      <field name="orderItemSeqId" type="id"></field>
      <field name="shipGroupSeqId" type="id"></field>
      <field name="shipmentId" type="id"></field>
      <field name="shipmentItemSeqId" type="id"></field>
      <field name="returnId" type="id"></field>
      <field name="returnItemSeqId" type="id"></field>
      <field name="workEffortId" type="id"></field>
      <field name="fixedAssetId" type="id"></field>
      <field name="maintHistSeqId" type="id"></field>
      <field name="itemIssuanceId" type="id"></field>
      <field name="receiptId" type="id"></field>
      <field name="physicalInventoryId" type="id"></field>
      <field name="reasonEnumId" type="id"></field>
      <field name="description" type="description"></field>
      <prim-key field="inventoryItemId"/>
      <prim-key field="inventoryItemDetailSeqId"/>
      <relation type="one" fk-name="INV_ITDTL_ITMIS" rel-entity-name="ItemIssuance">
        <key-map field-name="itemIssuanceId"/>
      </relation>
      <relation type="one-nofk" rel-entity-name="WorkEffortInventoryAssign">
        <key-map field-name="workEffortId"/>
        <key-map field-name="inventoryItemId"/>
      </relation>
      <relation type="one-nofk" rel-entity-name="WorkEffortInventoryProduced">
        <key-map field-name="workEffortId"/>
        <key-map field-name="inventoryItemId"/>
      </relation>
      <relation type="one" fk-name="INV_ITDTL_SHRCT" rel-entity-name="ShipmentReceipt">
        <key-map field-name="receiptId"/>
      </relation>
      <relation type="one" fk-name="INV_ITDTL_PHINV" rel-entity-name="PhysicalInventory">
        <key-map field-name="physicalInventoryId"/>
      </relation>
      <relation title="Reason" fk-name="INV_ITDTL_REAS" rel-entity-name="Enumeration" type="one">
        <key-map field-name="reasonEnumId" rel-field-name="enumId"/>
      </relation>
      <relation type="one-nofk" rel-entity-name="InventoryItemVariance">
        <key-map field-name="inventoryItemId"/>
        <key-map field-name="physicalInventoryId"/>
      </relation>
      <!-- 其他关系略 -->
    </entity>
```

从中我们也可以看出 OFBiz 考虑到哪些“单据”可能会影响库存的变化。比如装运单（`shipmentId`）、退货单（`returnId`）、工作单（`workEffortId`）、盘点单（`physicalInventoryId`）等。

---

对比一下原 WMS 的 InventoryItemEntry 实体的定义：

```yaml
aggregates:
    InventoryItem:
      id:
        name: InventoryItemId
        type: InventoryItemId
      properties:
        # 数量相关属性略

        # 库存事务条目（分录）
        Entries:
          itemType: InventoryItemEntry
          
        InventoryItemIdentifications:
          itemType: InventoryItemIdentification
      
      entities:
        # --------------- 库存事务条目（分录） ------------------
        InventoryItemEntry:
          immutable: true
          id:
            name: EntrySeqId
            type: long
            columnName: EntrySeqId
          properties:
            # 在库数量（变化），命名考虑改为 quantityOnHandDelta
            OnHandQuantity:
              type: decimal
            # 在途数量（变化），命名考虑改为 quantityInTransitDelta
            InTransitQuantity:
              type: decimal
            # 保留数量（变化），命名考虑改为 quantityReservedDelta
            ReservedQuantity:
              type: decimal
            # 占用数量（变化），命名考虑改为 quantityOccupiedDelta
            OccupiedQuantity:
              type: decimal
            # 虚拟数量（变化），命名考虑改为 quantityVirtualDelta
            VirtualQuantity:
              type: decimal
            # 来源信息
            Source:
              type: InventoryItemSourceInfo
              notNull: true
            # 库存事务（交易）的发生时间
            OccurredAt:
              type: date-time
              notNull: true
          # 唯一约束
          uniqueConstraints:
            # 一个“来源”不能重复产生库存事务（分录）
            UniqueInventoryItemSource: [Source]
          # ------------------------------
      
        InventoryItemIdentification:
          id: 
            name: InventoryItemIdentificationTypeId
            type: id-ne            
          properties:
            IdValue:
              type: string
              notNull: true
            Scope:
              type: id
              notNull: true
          uniqueConstraints:
            UniqueInventoryItemId: [Scope, IdValue]
      
      # ---------------- Value Objects -------------------
      valueObjects:      
        #InventoryItemId:
        #  properties:
        #    # 属性略（产品 Id 等）

        # 库存单元来源信息（命名改进一下？比如 InventoryItemEntryDocumentReference）
        InventoryItemSourceInfo:
          properties:
            # 单据类型 Id.
            # Document type identifier.
            DocumentTypeId:
              type: string # id
              referenceType: DocumentType
              notNull: true
            # 单据号
            # Document number.
            DocumentNumber:
              type: string # id-long
              notNull: true
            # 行号
            # Line number.
            LineNumber: # id-long （重命名为 DocumentLine 合适吗？）
              type: string
            # 单据行项的子项（一个源单据行项可能需要产生多个库存事务条目，这个 Id 用于进一步区分这些条目）
            # Sub-identifier for line items
            # (Used to distinguish multiple inventory transaction entries that may be generated from a single source document line item).
            LineSubSeqId:
              type: int # id（也许可以考虑重新命名为 LineSubId）
```

对库存条目（库存单元变动、库存单元明细）的记录，WMS 的方案似乎更具备可扩展性，可以考虑在适当改进后继续使用。


## PhysicalInventory 实体

OFBiz 的 PhysicalInventory（库存盘点）实体定义：

```xml
    <entity entity-name="PhysicalInventory"
            package-name="org.apache.ofbiz.product.inventory"
            title="Physical Inventory">
      <field name="physicalInventoryId" type="id"></field>
      <field name="physicalInventoryDate" type="date-time"></field>
      <field name="partyId" type="id"></field>
      <field name="generalComments" type="comment"></field>
      <prim-key field="physicalInventoryId"/>
    </entity>
```

## InventoryItemVariance 实体

OFBiz 的 InventoryItemVariance（库存差异）实体定义：

```xml
    <entity entity-name="InventoryItemVariance"
            package-name="org.apache.ofbiz.product.inventory"
            title="Inventory Item Variance">
      <field name="inventoryItemId" type="id"></field>
      <field name="physicalInventoryId" type="id"></field>
      <field name="varianceReasonId" type="id"></field>
      <field name="availableToPromiseVar" type="fixed-point"></field>
      <field name="quantityOnHandVar" type="fixed-point"></field>
      <field name="comments" type="comment"></field>
      <prim-key field="inventoryItemId"/>
      <prim-key field="physicalInventoryId"/>
      <relation type="one" fk-name="INV_ITEM_VAR_PINV" rel-entity-name="PhysicalInventory">
        <key-map field-name="physicalInventoryId"/>
      </relation>
      <relation type="one" fk-name="INV_ITEM_VAR_RSN" rel-entity-name="VarianceReason">
        <key-map field-name="varianceReasonId"/>
      </relation>
      <relation type="one" fk-name="INV_ITEM_VAR_ITEM" rel-entity-name="InventoryItem">
        <key-map field-name="inventoryItemId"/>
      </relation>
    </entity>
```

## FacilityLocation 实体

OFBiz 的 FacilityLocation 实体定义：

```xml
    <entity entity-name="FacilityLocation" package-name="org.apache.ofbiz.product.facility" title="Facility Location">
        <field name="facilityId" type="id"></field>
        <field name="locationSeqId" type="id"></field>
        <field name="locationTypeEnumId" type="id"></field>
        <field name="areaId" type="id"></field>
        <field name="aisleId" type="id"></field>
        <field name="sectionId" type="id"></field>
        <field name="levelId" type="id"></field>
        <field name="positionId" type="id"></field>
        <field name="geoPointId" type="id"></field>      
        <prim-key field="facilityId"/>
        <prim-key field="locationSeqId"/>
        <relation type="one" fk-name="FACILITY_LOC_FAC" rel-entity-name="Facility">
            <key-map field-name="facilityId"/>
        </relation>
        <relation type="one" fk-name="FACILITY_LOC_TENM" title="Type" rel-entity-name="Enumeration">
            <key-map field-name="locationTypeEnumId" rel-field-name="enumId"/>
        </relation>
      <relation type="one" fk-name="FACILITY_LOC_GEOPT" rel-entity-name="GeoPoint">
        <key-map field-name="geoPointId"/>
      </relation>      
    </entity>
```


## InventoryTransfer 实体

OFBiz 的 InventoryTransfer 实体定义：

```xml
    <entity entity-name="InventoryTransfer"
            package-name="org.apache.ofbiz.product.inventory"
            title="Inventory Transfer">
      <field name="inventoryTransferId" type="id"></field>
      <field name="statusId" type="id"></field>
      <field name="inventoryItemId" type="id"></field>
      <field name="facilityId" type="id"></field>
      <field name="locationSeqId" type="id"></field>
      <field name="containerId" type="id"></field>
      <field name="facilityIdTo" type="id"></field>
      <field name="locationSeqIdTo" type="id"></field>
      <field name="containerIdTo" type="id"></field>
      <field name="itemIssuanceId" type="id"></field>
      <field name="sendDate" type="date-time"></field>
      <field name="receiveDate" type="date-time"></field>
      <field name="comments" type="comment"></field>
      <prim-key field="inventoryTransferId"/>
      <relation type="one" fk-name="INV_XFER_ITEM" rel-entity-name="InventoryItem">
        <key-map field-name="inventoryItemId"/>
      </relation>
      <relation type="one" fk-name="INV_XFER_STTS" rel-entity-name="StatusItem">
        <key-map field-name="statusId"/>
      </relation>
      <relation type="one" fk-name="INV_XFER_FAC" rel-entity-name="Facility">
        <key-map field-name="facilityId"/>
      </relation>
      <relation type="one-nofk" rel-entity-name="FacilityLocation">
        <key-map field-name="facilityId"/>
        <key-map field-name="locationSeqId"/>
      </relation>
      <relation type="one" fk-name="INV_XFER_CONT" rel-entity-name="Container">
        <key-map field-name="containerId"/>
      </relation>
      <relation type="one" fk-name="INV_XFER_TFAC" title="To" rel-entity-name="Facility">
        <key-map field-name="facilityIdTo" rel-field-name="facilityId"/>
      </relation>
      <relation type="one-nofk" title="To" rel-entity-name="FacilityLocation">
        <key-map field-name="facilityIdTo" rel-field-name="facilityId"/>
        <key-map field-name="locationSeqIdTo" rel-field-name="locationSeqId"/>
      </relation>
      <relation type="one" fk-name="INV_XFER_TCNT" title="To" rel-entity-name="Container">
        <key-map field-name="containerIdTo" rel-field-name="containerId"/>
      </relation>
      <relation type="one" fk-name="INV_XFER_ISSU" rel-entity-name="ItemIssuance">
        <key-map field-name="itemIssuanceId"/>
      </relation>
    </entity>
```

## Shipment 相关实体

### Shipment 实体

OFBiz 的 Shipment 实体定义：

```xml
    <entity entity-name="Shipment"
            package-name="org.apache.ofbiz.shipment.shipment"
            title="Shipment">
      <field name="shipmentId" type="id"></field>
      <field name="shipmentTypeId" type="id"></field>
      <field name="statusId" type="id"></field>
      <field name="primaryOrderId" type="id"></field>
      <field name="primaryReturnId" type="id"></field>
      <field name="primaryShipGroupSeqId" type="id"></field>
      <field name="picklistBinId" type="id"></field>
      <field name="estimatedReadyDate" type="date-time"></field>
      <field name="estimatedShipDate" type="date-time"></field>
      <field name="estimatedShipWorkEffId" type="id"></field>
      <field name="estimatedArrivalDate" type="date-time"></field>
      <field name="estimatedArrivalWorkEffId" type="id"></field>
      <field name="latestCancelDate" type="date-time"></field>
      <field name="estimatedShipCost" type="currency-amount"></field>
      <field name="currencyUomId" type="id"></field>
      <field name="handlingInstructions" type="long-varchar"></field>
      <field name="originFacilityId" type="id"></field>
      <field name="destinationFacilityId" type="id"></field>
      <field name="originContactMechId" type="id"></field>
      <field name="originTelecomNumberId" type="id"></field>
      <field name="destinationContactMechId" type="id"></field>
      <field name="destinationTelecomNumberId" type="id"></field>
      <field name="partyIdTo" type="id"></field>
      <field name="partyIdFrom" type="id"></field>
      <field name="additionalShippingCharge" type="currency-amount"></field>
      <field name="addtlShippingChargeDesc" type="long-varchar"></field>
      <field name="createdDate" type="date-time"></field>
      <field name="createdByUserLogin" type="id-vlong"></field>
      <field name="lastModifiedDate" type="date-time"></field>
      <field name="lastModifiedByUserLogin" type="id-vlong"></field>
      <prim-key field="shipmentId"/>
      <relation type="one" fk-name="SHPMNT_TYPE" rel-entity-name="ShipmentType">
        <key-map field-name="shipmentTypeId"/>
      </relation>
      <!-- 其他关系略 -->
    </entity>
```

### ShipmentItem 实体

OFBiz 的 ShipmentItem 实体定义：

```xml
    <entity entity-name="ShipmentItem"
            package-name="org.apache.ofbiz.shipment.shipment"
            title="Shipment Item">
      <field name="shipmentId" type="id"></field>
      <field name="shipmentItemSeqId" type="id"></field>
      <field name="productId" type="id"></field>
      <field name="quantity" type="fixed-point"></field>
      <field name="shipmentContentDescription" type="description"></field>
      <prim-key field="shipmentId"/>
      <prim-key field="shipmentItemSeqId"/>
      <relation type="one" fk-name="SHPMNT_ITM_SHPMT" rel-entity-name="Shipment">
        <key-map field-name="shipmentId"/>
      </relation>
      <relation type="one" fk-name="SHPMNT_ITM_PROD" rel-entity-name="Product">
        <key-map field-name="productId"/>
      </relation>
    </entity>
```

### ShippingDocument 实体

OFBiz 的 ShippingDocument 实体定义：

```xml
    <entity entity-name="ShippingDocument"
            package-name="org.apache.ofbiz.shipment.shipment"
            title="Shipping Document">
      <field name="documentId" type="id"></field>
      <field name="shipmentId" type="id"></field>
      <field name="shipmentItemSeqId" type="id"></field>
      <field name="shipmentPackageSeqId" type="id"></field>
      <field name="description" type="description"></field>
      <prim-key field="documentId"/>
      <relation type="one" fk-name="SHPNG_DOC_DOC" rel-entity-name="Document">
        <key-map field-name="documentId"/>
      </relation>
      <relation type="one" fk-name="SHPNG_DOC_SMITM" rel-entity-name="ShipmentItem">
        <key-map field-name="shipmentId"/>
        <key-map field-name="shipmentItemSeqId"/>
      </relation>
      <relation type="one" fk-name="SHPNG_DOC_SHPKG" rel-entity-name="ShipmentPackage">
        <key-map field-name="shipmentId"/>
        <key-map field-name="shipmentPackageSeqId"/>
      </relation>
    </entity>
```

### ASN (Advanced Shipping Notice)

ASN 是发货方在发货前或发货时向收货方发送的详细电子通知。

ASN 包含的信息：

1. **基础信息**
   - ASN 编号
   - 发送日期和时间
   - 预计到达日期（ETA）
2. **参与方信息**
   - 发货方信息
   - 收货方信息
   - 承运人信息
3. **参考文档**
   - 采购订单号
   - 销售订单号
   - 装运单号
   - 集装箱号
4. **货物信息**
   - 产品编号（SKU）
   - 批次号（Batch/Lot）
   - 序列号（Serial Number）
   - 数量和单位
   - 包装层次结构

似乎我们可以直接将 Shipping 实体用作 ASN 的“实现”。（如果有必要，可以利用 ShippingDocument 实体来记录 ASN 的额外信息。）


## OrderShipment 实体

OFBiz 的 OrderShipment 实体用于记录 Order 和 Shipment 之间的关联关系：

```xml
    <entity entity-name="OrderShipment"
            package-name="org.apache.ofbiz.order.order"
            never-cache="true"
            title="Order Shipment">
      <field name="orderId" type="id"></field>
      <field name="orderItemSeqId" type="id"></field>
      <field name="shipGroupSeqId" type="id"></field>
      <field name="shipmentId" type="id"></field>
      <field name="shipmentItemSeqId" type="id"></field>
      <field name="quantity" type="fixed-point"></field>
      <prim-key field="orderId"/>
      <prim-key field="orderItemSeqId"/>
      <prim-key field="shipGroupSeqId"/>
      <prim-key field="shipmentId"/>
      <prim-key field="shipmentItemSeqId"/>
      <relation type="one" fk-name="ORDER_SHPMT_OHDR" rel-entity-name="OrderHeader">
        <key-map field-name="orderId"/>
      </relation>
      <relation type="one-nofk" rel-entity-name="OrderItem">
        <key-map field-name="orderId"/>
        <key-map field-name="orderItemSeqId"/>
      </relation>
      <relation type="one" fk-name="ORDER_SHPMT_SHPMT" rel-entity-name="Shipment">
        <key-map field-name="shipmentId"/>
      </relation>
      <relation type="one-nofk" rel-entity-name="ShipmentItem">
        <key-map field-name="shipmentId"/>
        <key-map field-name="shipmentItemSeqId"/>
      </relation>
      <relation type="one-nofk" rel-entity-name="OrderItemShipGroupAssoc">
        <key-map field-name="orderId"/>
        <key-map field-name="orderItemSeqId"/>
        <key-map field-name="shipGroupSeqId"/>
      </relation>
    </entity>
```

但是 OrderShipment 实体中的“数量”更多可以理解为“计划数量”（所以预先发货通知的数量可以考虑记录在这里）。


## ShipmentReceipt 实体

和记录发货操作的 ItemIssuance 实体相对应，ShipmentReceipt 实体用于记录“收货”操作。

OFBiz 的 ShipmentReceipt 实体定义：

```xml
    <entity entity-name="ShipmentReceipt"
            package-name="org.apache.ofbiz.shipment.receipt"
            title="Shipment Receipt">
      <field name="receiptId" type="id"></field>
      <field name="inventoryItemId" type="id"></field>
      <field name="productId" type="id"></field>
      <field name="shipmentId" type="id"></field>
      <field name="shipmentItemSeqId" type="id"></field>
      <field name="shipmentPackageSeqId" type="id"></field>
      <field name="orderId" type="id"></field>
      <field name="orderItemSeqId" type="id"></field>
      <field name="returnId" type="id"></field>
      <field name="returnItemSeqId" type="id"></field>
      <field name="rejectionId" type="id"></field>
      <field name="receivedByUserLoginId" type="id-vlong"></field>
      <field name="datetimeReceived" type="date-time"></field>
      <field name="itemDescription" type="description"></field>
      <field name="quantityAccepted" type="fixed-point"></field>
      <field name="quantityRejected" type="fixed-point"></field>
      <prim-key field="receiptId"/>
      <relation type="one" fk-name="SHP_RCPT_INVITM" rel-entity-name="InventoryItem">
        <key-map field-name="inventoryItemId"/>
      </relation>
      <relation type="one" fk-name="SHP_RCPT_SHPKG" rel-entity-name="ShipmentPackage">
        <key-map field-name="shipmentId"/>
        <key-map field-name="shipmentPackageSeqId"/>
      </relation>
      <relation type="one" fk-name="SHP_RCPT_ORDITM" rel-entity-name="OrderItem">
        <key-map field-name="orderId"/>
        <key-map field-name="orderItemSeqId"/>
      </relation>
      <relation type="one-nofk" fk-name="SHP_RCPT_SHIPIT" rel-entity-name="ShipmentItem">
        <key-map field-name="shipmentId"/>
        <key-map field-name="shipmentItemSeqId"/>
      </relation>
      <relation type="one" fk-name="SHP_RCPT_RETINVITM" rel-entity-name="ReturnItem">
        <key-map field-name="returnId"/>
        <key-map field-name="returnItemSeqId"/>
      </relation>
      <!-- 其他关系略 -->
    </entity>
```

> 注：
> 
> 在 OFBiz 中，Return / ReturnItem（退货单）常常和特定类型的“装运单”相关联。
> 和退货相关的装运单类型通常包括 `PURCHASE_RETURN`（“我”退货/发货给“供应商”） 、`SALES_RETURN`（“客户”退货/发货给“我”）。


## “收货”（Receiving）实现方案

### 需求考虑

实际项目中，各种“单据”的缺失是一个恼人但是又常见的问题。这里需要考虑如何支持“无订单”收货。


### 方案一：使用“装运单” 和 ShipmentReceipt 实体

在收货的时候，“临时创建”一个装运单（Shipment），然后使用 ShipmentReceipt 实体记录收货操作。
ShipmentReceipt 的 `shipmentId` 字段引用这个装运单（不允许为空）。

使用 ShipmentDocument 实体来记录这个装运单关联的文档信息。

BFF 服务向前端暴露的“收货单”（DTO 对象）包含两个“集合类型”的属性：

```yaml
valueObjects:
  BffReceivingDocumentDto: # 收货单 DTO
    properties:
      # ...
      ReceivingItems:
        # 行项信息主要来自 ShipmentReceipt 实体
        itemType: BffReceivingItemDto
        isList: true
      ReferenceDocuments:
        # 参考文档信息主要来自 ShippingDocument 实体
        itemType: id
        isList: true
```


### 方案二：“临时收货单据” / “无装运单”

另外一个可能的实现方案（使用“临时收货单据”）：

* 使用 Document 实体创建“临时收货单据”。（Temporary Receiving Document）
* 将这样的 Document 实体标记为特殊的类型（使用一个 `documentTypeId` 字段关联到 `DocumentType` 实体）。
* 允许 ShipmentReceipt 实体的 `orderId`，`shipmentId` 等字段为空，使用这个实体来记录“无订单”、“无装运单”的收货操作。
* 为 ShipmentReceipt 实体中添加一个属性 `receivingDocumentId`，引用上述的临时收货单形成“多对一”的关系。
* ShipmentReceipt 相当于“临时收货单”的行项（Item）。

考虑支持在收货后的“补录”操作。

* 允许在收货后，先补录采购订单，以及装运单的信息；
* 在用户界面上，允许将通过临时收货单（Document Id）查询出 ShipmentReceipt；
* 然后允许用户（通过“选择”的方式）将 ShipmentReceipt 的 `orderId`，`orderItemSeqId`，`shipmentId`，`shipmentItemSeqId` 关联到采购订单/订单行项、装运单/装运单行项。
* 也许还可以考虑不需要用户手动录入（以及选择）OrderItem、ShipmentItem，只需要录入 Order 和 Shipment 的信息，然后我们从 ShipmentReceipt 的记录“反推”应有的 OrderItem 和 ShipmentItem，自动“补录”并完成关联。
* 考虑将这些自动补录的 OrderItem 和 ShipmentItem 进行标记？
  * OFBiz 中存在 `OrderItemType` 实体；
  * 但是在 OFBiz 中不存在 `ShipmentItemType` 实体。

收货时可能有关联的文档需要保存，假设这些文档也属于“Document”，那么，似乎需要引入一个 DocumentAssociation 实体。
（如果采用上面的“方案一”，那么 DocumentAssociation 可能不需要。）


### 考虑使用“异步事件”机制

如果“自动补录”的逻辑比较复杂，可能需要考虑使用“异步事件”机制来处理。

另外，从“原始操作记录”生成食品追溯的 CTEs，可能也需要使用“异步事件”机制。

使用“异步事件”机制，可能会存在处理失败的情况。应对措施：

* 打印合适的日志，对日志进行兼容。
* 使用 scheduled task 机制，定期检查需要触发“异步事件处理”、但是没有处理成功的记录（“原始事件”），执行重试。


## ItemIssuance 实体

一般来说，ItemIssuance 实体在“实际发货”层面记录的、Order（订单）和 Shipment（装运单）之间的关联关系的实体。

但是如果我们允许 `orderId`，`shipmentId` 这些字段为空，那么这个实体可以记录“无订单”、“无装运单”的发货操作。

OFBiz 的 ItemIssuance 实体用于记录“发货”操作：

```xml
    <entity entity-name="ItemIssuance"
            package-name="org.apache.ofbiz.shipment.issuance"
            title="Item Issuance">
      <field name="itemIssuanceId" type="id"></field>
      <field name="orderId" type="id"></field>
      <field name="orderItemSeqId" type="id"></field>
      <field name="shipGroupSeqId" type="id"></field>
      <field name="inventoryItemId" type="id"></field>
      <field name="shipmentId" type="id"></field>
      <field name="shipmentItemSeqId" type="id"></field>
      <field name="fixedAssetId" type="id"></field>
      <field name="maintHistSeqId" type="id"></field>
      <field name="issuedDateTime" type="date-time"></field>
      <field name="issuedByUserLoginId" type="id-vlong"></field>
      <field name="quantity" type="fixed-point"></field>
      <field name="cancelQuantity" type="fixed-point"></field>
      <prim-key field="itemIssuanceId"/>
      <relation type="one" fk-name="ITEM_ISS_INVITM" rel-entity-name="InventoryItem">
        <key-map field-name="inventoryItemId"/>
      </relation>
      <relation type="one-nofk" rel-entity-name="OrderItemShipGrpInvRes">
        <key-map field-name="orderId"/>
        <key-map field-name="orderItemSeqId"/>
        <key-map field-name="shipGroupSeqId"/>
        <key-map field-name="inventoryItemId"/>
      </relation>
      <relation type="one-nofk" rel-entity-name="Shipment">
        <key-map field-name="shipmentId"/>
      </relation>
      <relation type="one" fk-name="ITEM_ISS_SHITM" rel-entity-name="ShipmentItem">
        <key-map field-name="shipmentId"/>
        <key-map field-name="shipmentItemSeqId"/>
      </relation>
      <relation type="one" fk-name="ITEM_ISS_FAMNT" rel-entity-name="FixedAssetMaint">
        <key-map field-name="fixedAssetId"/>
        <key-map field-name="maintHistSeqId"/>
      </relation>
      <relation type="one-nofk" rel-entity-name="OrderHeader">
        <key-map field-name="orderId"/>
      </relation>
      <relation type="one" fk-name="ITEM_ISS_ORITM" rel-entity-name="OrderItem">
        <key-map field-name="orderId"/>
        <key-map field-name="orderItemSeqId"/>
      </relation>
      <relation type="one" fk-name="ITEM_ISS_IBUL" title="IssuedBy" rel-entity-name="UserLogin">
        <key-map field-name="issuedByUserLoginId" rel-field-name="userLoginId"/>
      </relation>
    </entity>
```

在其他项目（Pmall 项目）中，我们也尝试过将这个实体建模为独立的聚合根——似乎这个设计更合理。

另外，在这个实体上加上 AttributeSetInstanceId 应该是有必要的，用于标识实际发货的产品的属性。


## Lot 实体

```xml
    <entity entity-name="Lot"
            package-name="org.apache.ofbiz.product.inventory"
            title="Lot">
      <field name="lotId" type="id"></field>
      <field name="creationDate" type="date-time"></field>
      <field name="quantity" type="fixed-point"></field>
      <field name="expirationDate" type="date-time"></field>
      <prim-key field="lotId"/>
    </entity>
```

### 考虑增加一个 LotIdentification 实体

Lot 实体的 lotId 字段，为了避免冲突，可能我们需要使用“内部 Lot Id”（类似自动生成的“代理键”）。

这里可以参考 PartyIdentification 实体的设计。类似这样：

```xml
     <entity entity-name="LotIdentification">
      <field name="lotId" type="id"></field>
      <field name="lotIdentificationTypeId" type="id"></field>
      <field name="idValue" type="id-long"></field>
      <prim-key field="partyId"/>
      <prim-key field="partyIdentificationTypeId"/>
      <relation type="one" fk-name="LOT_ID_TYPE" rel-entity-name="LotIdentificationType">
        <key-map field-name="lotIdentificationTypeId"/>
      </relation>
      <index name="LOT_ID_VALIDX" unique="false">
          <index-field name="idValue"/>
      </index>
    </entity> 
```

通过这个实体，可以将 Lot Id 映射到 GS1 标准的 BATCH/LOT 标识。

### GS1 BATCH/LOT (AI=10) 规范

#### 基本要求

1. **数据标识符**
   - Application Identifier (AI): 10
   - 用于标识批次或批号

2. **格式要求**
   - 最大长度：20个字符
   - 字符类型：字母数字（alphanumeric）
   - 可变长度
   - GS1 AI (10) = X₁₋₂₀ an

3. **字符集要求**
   - 可以包含数字 (0-9)
   - 可以包含大写字母 (A-Z)
   - 可以包含特殊字符（如 / - . _）
   - 建议避免使用可能造成混淆的字符

#### 正则表达式

可以考虑使用正则表达式来验证批次号：

```
// 基本要求：
// 1. 最大长度：20个字符
// 2. 字符类型：字母数字（alphanumeric）
// 3. 可变长度
// 4. 可以包含数字 (0-9)
// 5. 可以包含大写字母 (A-Z)
// 6. 可以包含特殊字符（如 / - . _）

// 正则表达式
^[A-Z0-9/\-._]{1,20}$

// 合法的批次号
"ABC123"            // true
"BATCH/001"         // true
"LOT-2023.001"      // true
"PROD_2023_Q1"      // true

// 不合法的批次号
"abc123"            // false (小写字母)
"BATCH#001"         // false (非法字符 #)
"BATCH_NUMBER_TOO_LONG" // false (超过20个字符)
"" // false (空字符串)
```


#### 最佳实践

1. **批号设计建议**
   - 保持一致的格式
   - 避免使用容易混淆的字符（如 I 和 1，O 和 0）
   - 考虑包含有意义的信息（如生产日期、生产线等）

2. **常见格式示例**
   ```
   ABC123        // 简单字母数字组合
   2023A123      // 年份+序列号
   L123456       // 生产线+序列号
   23001-A1      // 年月+序列号
   ```

#### 注意事项

1. **扫描考虑**
   - 确保打印质量清晰
   - 字符间距适当
   - 避免使用易混淆的字符组合

2. **系统集成**
   - 确保系统能够处理变长字段
   - 考虑数据库字段长度设置
   - 建议预留足够的字段长度（至少20字符）


## PartyIdentification 实体

```xml
     <entity entity-name="PartyIdentification"
            package-name="org.apache.ofbiz.party.party"
            title="Party Identification">
      <field name="partyId" type="id"></field>
      <field name="partyIdentificationTypeId" type="id"></field>
      <field name="idValue" type="id-long"></field>
      <prim-key field="partyId"/>
      <prim-key field="partyIdentificationTypeId"/>
      <relation type="one" fk-name="PARTY_ID_TYPE" rel-entity-name="PartyIdentificationType">
        <key-map field-name="partyIdentificationTypeId"/>
      </relation>
      <relation type="one" fk-name="PARTY_ID_PRODUCT" rel-entity-name="Party">
        <key-map field-name="partyId"/>
      </relation>
      <index name="PARTY_ID_VALIDX" unique="false">
          <index-field name="idValue"/>
      </index>
    </entity> 
```

### 使用 GGN (GLOBALG.A.P. Number)

GGN 是 GLOBALG.A.P. Number 的缩写：
   - GLOBALG.A.P. 编号
   - 由 GLOBALG.A.P. 组织分配的 13 位唯一标识符
   - 用于识别通过 GLOBALG.A.P. 认证的生产者或公司
   - 主要用于农业和水产养殖领域，表示符合良好农业规范标准

通过 PartyIdentification 可以将某个 PartyId 映射到 GGN。

### 使用 GLN (Global Location Number)

GLN (Global Location Number):
   - 全球位置编码
   - 由 GS1 分配的唯一标识符，用于识别公司、工厂、仓库等物理位置或法律实体
   - 在供应链中广泛使用，用于精确定位和识别参与者

可以通过 PartyIdentification 将 FacilityId 映射到 GLN。


## Facility（设施）实体

```xml
    <entity entity-name="Facility" package-name="org.apache.ofbiz.product.facility" title="Facility">
        <field name="facilityId" type="id"></field>
        <field name="facilityTypeId" type="id"></field>
        <field name="parentFacilityId" type="id"></field>
        <field name="ownerPartyId" type="id"/>
        <field name="defaultInventoryItemTypeId" type="id"></field>
        <field name="facilityName" type="name"></field>
        <field name="primaryFacilityGroupId" type="id"></field>
        <field name="facilitySize" type="fixed-point"></field>
        <field name="facilitySizeUomId" type="id"></field>
        <field name="productStoreId" type="id"></field>
        <field name="defaultDaysToShip" type="numeric"><description>In the absence of a product specific days to ship in ProductFacility, this will be used</description></field>
        <field name="openedDate" type="date-time"></field>
        <field name="closedDate" type="date-time"></field>
        <field name="description" type="description"></field>
        <field name="defaultDimensionUomId" type="id"><description>This field store the unit of measurement of dimension (length, width and height)</description></field>
        <field name="defaultWeightUomId" type="id"></field>
        <field name="geoPointId" type="id"></field>
        <field name="facilityLevel" type="numeric"><description>This field will define the level of facility.</description></field>
        <prim-key field="facilityId"/>
        <!-- 其他关系略 -->
    </entity>
```


### 考虑增加 FacilityIdentification 实体

考虑增加一个 FacilityIdentification 实体，以便支持将 FacilityId 映射到 FFRN 以及 GLN。

### 使用 FFRN (FDA Food Facility Registration Number)

FFRN (FDA Food Facility Registration Number):
   - FDA 食品设施注册号
   - 由美国食品和药物管理局 (FDA) 分配给食品生产、加工、包装或储存设施的唯一标识号
   - 根据生物恐怖主义法案要求，所有处理食品的设施都必须向 FDA 注册并获得此号码

### 使用 GLN (Global Location Number)

GLN (Global Location Number):
   - 全球位置编码
   - 由 GS1 分配的唯一标识符，用于识别公司、工厂、仓库等物理位置或法律实体
   - 在供应链中广泛使用，用于精确定位和识别参与者

可以通过 FacilityIdentification 将 FacilityId 映射到 GLN。


## Document 实体以及相关实体

Document 以及相关实体用于记录文档信息：

```xml
    <entity entity-name="Document"
            package-name="org.apache.ofbiz.content.document"
            title="Document">
      <field name="documentId" type="id"></field>
      <field name="documentTypeId" type="id"></field>
      <field name="dateCreated" type="date-time"></field>
      <field name="comments" type="comment"></field>
      <field name="documentLocation" type="long-varchar"></field>
      <field name="documentText" type="long-varchar"></field>
      <field name="imageData" type="object"></field>
      <prim-key field="documentId"/>
      <relation type="one" fk-name="DOCUMENT_TO_TYPE" rel-entity-name="DocumentType">
        <key-map field-name="documentTypeId"/>
      </relation>
      <relation type="many" rel-entity-name="DocumentTypeAttr">
        <key-map field-name="documentTypeId"/>
      </relation>
    </entity>

    <entity entity-name="DocumentAttribute"
            package-name="org.apache.ofbiz.content.document"
            title="Document Attribute">
      <field name="documentId" type="id"></field>
      <field name="attrName" type="id-long"></field>
      <field name="attrValue" type="value"></field>
      <field name="attrDescription" type="description"></field>
      <prim-key field="documentId"/>
      <prim-key field="attrName"/>
      <relation type="one" fk-name="DOCUMENT_ATTR" rel-entity-name="Document">
        <key-map field-name="documentId"/>
      </relation>
      <relation type="many" rel-entity-name="DocumentTypeAttr">
        <key-map field-name="attrName"/>
      </relation>
    </entity>
    <entity entity-name="DocumentType"
            package-name="org.apache.ofbiz.content.document"
            default-resource-name="ContentEntityLabels"
            title="Document Type">
      <field name="documentTypeId" type="id"></field>
      <field name="parentTypeId" type="id"></field>
      <field name="hasTable" type="indicator"></field>
      <field name="description" type="description"></field>
      <prim-key field="documentTypeId"/>
      <relation type="one" fk-name="DOC_TYPE_PARENT" title="Parent" rel-entity-name="DocumentType">
        <key-map field-name="parentTypeId" rel-field-name="documentTypeId"/>
      </relation>
    </entity>

    <entity entity-name="DocumentTypeAttr"
            package-name="org.apache.ofbiz.content.document"
            title="Document Type Attribute">
      <field name="documentTypeId" type="id"></field>
      <field name="attrName" type="id-long"></field>
      <field name="description" type="description"></field>
      <prim-key field="documentTypeId"/>
      <prim-key field="attrName"/>
      <relation type="one" fk-name="DOC_TYPE_ATTR" rel-entity-name="DocumentType">
        <key-map field-name="documentTypeId"/>
      </relation>
      <relation type="many" rel-entity-name="DocumentAttribute">
        <key-map field-name="attrName"/>
      </relation>
      <relation type="many" rel-entity-name="Document">
        <key-map field-name="documentTypeId"/>
      </relation>
    </entity>
```


## 考虑收货的 QA 操作

### 检验单（QaInspection）

属性：

- `qaInspectionId`: 检验单号
- `inspectedBy`: 检验员ID
- `inspectedAt`: 检验日期时间
- `inspectionTypeId`: 检验类型（收货/生产/出货）
- `statusId`: 状态（待检/检验中/已完成/已关闭）
- `productId`: 产品ID
- `lotId`: 批次 Id
- `sampleSize`: 抽样数量
- `sampleUomId`: 抽样单位
- `resultId`: 检验结果（合格/不合格/部分合格）
- `receiptId`: 关联的收货记录 Id
- `supplierPartyId`: 供应商ID
- `facilityId`: 仓库ID
- `qualityLevelId`: 质量等级
- `referenceDocs`: 相关单据号。**也许暂时不需要。如果需要，可能更好的方式是使用一个（聚合内）实体来记录关联的单据。**
- `comments`: 备注
- `createdAt`: 创建时间
- `updatedAt`: 更新时间

上面命名为 `xxxId` 的字段，会关联到其他实体，比如“QaInspectionType”、“QaInspectionResult”、“ProductQualityLevel”实体等。


### 检验项目（QaInspectionItem）

属性：

- `qaInspectionId`: 关联的检验单号
- `qaInspectionItemSeqId`: 检验项目 ID
- `qaCheckItemId`: 检验项目定义ID
- `standardValue`: 标准值
- `actualValue`: 实测值
- `toleranceUpper`: 上限公差
- `toleranceLower`: 下限公差
- `resultId`: 项目检验结果
- `defectQuantity`: 不合格数量
- `defectSeverityId`: 缺陷程度（严重/一般/轻微）
- `testEquipmentId`: 测试设备
- `measurementUnitId`: 测量单位，是否需要？
  - 这个名称含义不太明确。如果是“测量值”的单位，似乎可以命名为 `valueUomId`？
  - 如果需要，似乎可以作为关联的 `QaCheckItem` 实体中的属性就可以？
- `testCondition`: 测试条件。备注型字段？暂时不需要？
- `comments`: 备注
- `createdAt`: 创建时间



### 检验项目定义（QaCheckItem）

属性：

- `qaCheckItemId`: 检验项目定义ID
- `itemCode`: 项目代码
- `itemName`: 项目名称
- `itemType`: 项目类型（定性/定量）
- `checkMethod`: 检验方法，备注型字段？或者命名为 `comments` 或者 `checkMethodComments`？
- `standardValue`: 标准值
- `toleranceUpper`: 默认上限公差
- `toleranceLower`: 默认下限公差
- `isRequired`: 是否必检
- `active`: 是否启用
- `createdAt`: 创建时间


## Uom 实体

```xml
    <entity entity-name="Uom"
            package-name="org.apache.ofbiz.common.uom"
            default-resource-name="CommonEntityLabels"
            title="Unit Of Measure">
      <field name="uomId" type="id"></field>
      <field name="uomTypeId" type="id"></field>
      <field name="abbreviation" type="short-varchar"></field>
      <field name="numericCode" type="numeric"></field>
      <field name="description" type="description"></field>
      <prim-key field="uomId"/>
      <relation type="one" fk-name="UOM_TO_TYPE" rel-entity-name="UomType">
        <key-map field-name="uomTypeId"/>
      </relation>
    </entity>
```

### UOM 使用 GS1 Application Identifiers

参考：https://ref.gs1.org/ai/

这里的 Uom 可以考虑使用 GS1 Application Identifiers 的 UOM 部分。

这类 UOM ID 使用特定的前缀？或者没有必要？比如 `AI-3100` vs `3100`。但是 `uomTypeId` 字段需要明确标识为 GS1 Application Identifiers。


可以这样将 GS1 AI 导入到 UOM 表： 

```sql
INSERT INTO uom (uom_id, uom_type_id, abbreviation, numeric_code, description)
SELECT 
    'AI-' || application_identifier AS uom_id,
    'GS1_AI' AS uom_type_id,
    label_ AS abbreviation,
    CASE 
        WHEN application_identifier ~ '^\d+$' THEN application_identifier::int -- 这里假设 numeric_code 列类型是 int
        ELSE NULL
    END AS numeric_code,
    description
FROM 
    gs1_application_identifier 
WHERE 
    application_identifier like '3%'
;
```



## Return 相关实体

OFBiz 中和“退货”相关的实体：

```xml
    <entity entity-name="ReturnHeader"
            package-name="org.apache.ofbiz.order.return"
            title="Return">
        <field name="returnId" type="id"></field>
        <field name="returnHeaderTypeId" type="id"></field>
        <field name="statusId" type="id"></field>
        <field name="createdBy" type="id-vlong"></field>
        <field name="fromPartyId" type="id"></field>
        <field name="toPartyId" type="id"></field>
        <field name="paymentMethodId" type="id"></field>
        <field name="finAccountId" type="id"></field>
        <field name="billingAccountId" type="id"></field>
        <field name="entryDate" type="date-time"></field>
        <field name="originContactMechId" type="id"></field>
        <field name="destinationFacilityId" type="id"></field>
        <field name="needsInventoryReceive" type="indicator"></field>
        <field name="currencyUomId" type="id"></field>
        <field name="supplierRmaId" type="id"></field>
        <prim-key field="returnId"/>
        <relation type="one" fk-name="RTN_HEAD_TYPE" rel-entity-name="ReturnHeaderType">
            <key-map field-name="returnHeaderTypeId"/>
        </relation>
        <!-- 其他关系略 -->
    </entity>

    <entity entity-name="ReturnItem"
            package-name="org.apache.ofbiz.order.return"
            title="Return Item">
        <field name="returnId" type="id"></field>
        <field name="returnItemSeqId" type="id"></field>
        <field name="returnReasonId" type="id" enable-audit-log="true">
            <description>why item is returned: did not like, wrong item, damaged, etc. etc.</description>
        </field>
        <field name="returnTypeId" type="id" enable-audit-log="true">
            <description>actually used for disbursement type: store credit, cash refund, exchange</description>
        </field>
        <field name="returnItemTypeId" type="id">
            <description>what is returned: a product, a service, etc</description>
        </field>
        <field name="productId" type="id">
            <description>we need this field to be able to figure out net sales of a product</description>
        </field>
        <field name="description" type="description"></field>
        <field name="orderId" type="id"></field>
        <field name="orderItemSeqId" type="id"></field>
        <field name="statusId" type="id"></field>
        <field name="expectedItemStatus" type="id"></field>
        <field name="returnQuantity" type="fixed-point" enable-audit-log="true"><description>promised by the customer</description></field>
        <field name="receivedQuantity" type="fixed-point" enable-audit-log="true"><description>actually received from the customer</description></field>
        <field name="returnPrice" type="currency-amount" enable-audit-log="true"></field>
        <field name="returnItemResponseId" type="id"></field>
        <prim-key field="returnId"/>
        <prim-key field="returnItemSeqId"/>
        <relation type="one" fk-name="RTN_ITEM_RTN" rel-entity-name="ReturnHeader">
            <key-map field-name="returnId"/>
        </relation>
        <relation type="one" fk-name="RTN_ITEM_TYPE" rel-entity-name="ReturnItemType"> <!-- this is new -->
            <key-map field-name="returnItemTypeId"/>
        </relation>
        <relation type="one" fk-name="RTN_ITEM_RESP" rel-entity-name="ReturnItemResponse">
            <key-map field-name="returnItemResponseId"/>
        </relation>
        <relation type="one" fk-name="RTN_ITEM_ITSTT" title="Inventory" rel-entity-name="StatusItem">
            <key-map field-name="expectedItemStatus" rel-field-name="statusId"/>
        </relation>
        <index name="RTN_ITM_BYORDITM">
            <index-field name="orderId"/>
            <index-field name="orderItemSeqId"/>
        </index>
        <!-- 其他关系略 -->
    </entity>
```

## OrderItemType 实体

```xml
    <entity entity-name="OrderItemType"
            package-name="org.apache.ofbiz.order.order"
            default-resource-name="OrderEntityLabels"
            title="Order Item Type">
      <field name="orderItemTypeId" type="id"></field>
      <field name="parentTypeId" type="id"></field>
      <field name="hasTable" type="indicator"></field>
      <field name="description" type="description"></field>
      <prim-key field="orderItemTypeId"/>
      <relation type="one" fk-name="ORDER_ITEM_TYPPAR" title="Parent" rel-entity-name="OrderItemType">
        <key-map field-name="parentTypeId" rel-field-name="orderItemTypeId"/>
      </relation>
    </entity>
```


### PhysicalInventory 实体

```xml
    <entity entity-name="PhysicalInventory"
            package-name="org.apache.ofbiz.product.inventory"
            title="Physical Inventory">
      <field name="physicalInventoryId" type="id"></field>
      <field name="physicalInventoryDate" type="date-time"></field>
      <field name="partyId" type="id"></field>
      <field name="generalComments" type="comment"></field>
      <prim-key field="physicalInventoryId"/>
    </entity>
```


## OFBiz 中关联到 InventoryItem 的实体

使用关键字 `"inventoryItemId"` 搜索 `*-entitymodel.xml` 文件，可以找到关联到 InventoryItem 的实体。

部分实体：

* InvoiceItem
* OrderItemShipGrpInvRes (Order Item Inventory Reservation)
* InventoryItemDetail
* InventoryItemVariance
* InventoryItemLabelAppl (Inventory Item Label Applicability)
* InventoryTransfer
* Subscription
* ItemIssuance
* PicklistItem
* ShipmentReceipt
* WorkEffortInventoryAssign
* WorkEffortInventoryProduced

## Party（业务实体）相关实体

OFBiz 中 PartyRole 实体的定义：

```xml
    <entity entity-name="PartyRole"
            package-name="org.apache.ofbiz.party.party"
            title="Party Role">
      <field name="partyId" type="id"></field>
      <field name="roleTypeId" type="id"></field>
      <prim-key field="partyId"/>
      <prim-key field="roleTypeId"/>
      <relation type="one" fk-name="PARTY_RLE_PARTY" rel-entity-name="Party">
        <key-map field-name="partyId"/>
      </relation>
      <relation type="one" fk-name="PARTY_RLE_ROLE" rel-entity-name="RoleType">
        <key-map field-name="roleTypeId"/>
      </relation>
      <relation type="many" rel-entity-name="RoleTypeAttr">
        <key-map field-name="roleTypeId"/>
      </relation>
      <relation type="many" rel-entity-name="PartyAttribute">
        <key-map field-name="partyId"/>
      </relation>
    </entity>
```



## Spring Security / Spring Authorization Server 相关

这些 Schema 会用于用户认证/授权管理。

```sql
create table users(
    username varchar_ignorecase(50) not null primary key,
    password varchar_ignorecase(100) not null,
    enabled boolean not null
);

create table authorities (
    username varchar_ignorecase(50) not null,
    authority varchar_ignorecase(50) not null,
    constraint fk_authorities_users foreign key(username) references users(username)
);

-- -------------------- 测试数据 --------------------
INSERT INTO users (username, password, enabled)
VALUES (
    'user',
    '{bcrypt}$2a$10$x1Q04LMJq8HX/J4AlRldZuNWIpjFevyNAP3OGUHPAbwLiGTHDVaJW',  -- 'password' 加密后的值
    true
);

INSERT INTO users (username, password, enabled)
VALUES ('admin', '{bcrypt}$2a$10$x1Q04LMJq8HX/J4AlRldZuNWIpjFevyNAP3OGUHPAbwLiGTHDVaJW', true);

INSERT INTO users (username, password, enabled)
VALUES ('superuser', '{bcrypt}$2a$10$x1Q04LMJq8HX/J4AlRldZuNWIpjFevyNAP3OGUHPAbwLiGTHDVaJW', true);

INSERT INTO authorities (username, authority)
VALUES ('user', 'ROLE_USER');

-- -- 普通用户
-- INSERT INTO authorities VALUES ('user', 'ROLE_USER');

-- 管理员
INSERT INTO authorities VALUES ('admin', 'ROLE_ADMIN');

-- 一个用户可以有多个角色
INSERT INTO authorities VALUES ('superuser', 'ROLE_USER');
INSERT INTO authorities VALUES ('superuser', 'ROLE_ADMIN');

```

### Group Authorities / 实现 RBAC（基于角色的访问控制）

Spring Security 的 Group Authorities 其实更接近大多数人认知的“角色”的概念。

我们可以使用 Group Authorities 来实现“基于角色的访问控制”。

Group Authorities 相关 Schema：

```sql
create table groups (
	id bigint generated by default as identity(start with 0) primary key,
	group_name varchar_ignorecase(50) not null
);

create table group_authorities (
	group_id bigint not null,
	authority varchar(50) not null,
	constraint fk_group_authorities_group foreign key(group_id) references groups(id)
);

create table group_members (
	id bigint generated by default as identity(start with 0) primary key,
	username varchar(50) not null,
	group_id bigint not null,
	constraint fk_group_members_group foreign key(group_id) references groups(id)
);

-- -------------------- 测试数据 --------------------

-- 1. 首先创建用户
INSERT INTO users (username, password, enabled) VALUES 
    ('bob', '{bcrypt}$2a$10$x1Q04LMJq8HX/J4AlRldZuNWIpjFevyNAP3OGUHPAbwLiGTHDVaJW', true),
    ('alice', '{bcrypt}$2a$10$x1Q04LMJq8HX/J4AlRldZuNWIpjFevyNAP3OGUHPAbwLiGTHDVaJW', true);

-- 2. 创建用户组（注意：需要显式指定 ID）
INSERT INTO groups (id, group_name) VALUES 
    (1, 'ADMIN_GROUP'),
    (2, 'USER_GROUP');

-- 3. 分配组权限（现在 group_id 1和2已经存在了）
INSERT INTO group_authorities (group_id, authority) VALUES 
    (1, 'ROLE_ADMIN'),
    (2, 'ROLE_USER');

-- 4. 最后将用户加入组
INSERT INTO group_members (username, group_id) VALUES 
    ('bob', 1),    -- bob 加入 ADMIN_GROUP
    ('alice', 2);  -- alice 加入 USER_GROUP

```

## 命名规范

### 为什么选择使用 "Supplier" 命名？

#### 背景说明
在业务系统中，我们经常需要表达"供应商"这个概念。英语中 Supplier 和 Vendor 都可以表达这个含义，但我们选择使用 Supplier 进行命名。以下是主要原因：

##### 1. 业务关系深度
```
Supplier（我们的选择）：
- 代表长期、稳定的业务合作关系
- 通常涉及合同约束
- 更符合企业级应用场景

Vendor：
- 偏向短期或一次性交易
- 交易关系相对松散
- 更适合零售场景
```

##### 2. 供应链定位
```
Supplier：
- 位于供应链上游
- 直接参与生产和服务流程
- 强调专业性和稳定性

Vendor：
- 通常指代销售端角色
- 更接近终端消费者
- 强调交易性质
```

##### 3. 实际应用案例
```
Supplier 的典型场景：
- 原材料供应商
- 核心零部件提供商
- 专业服务供应商

Vendor 的典型场景：
- 零售商
- 经销商
- 代理商
```

##### 4. 命名建议
```
推荐使用场景：
- 实体类名：Supplier、SupplierProfile
- 变量命名：supplier、mainSupplier
- 表名：t_supplier、supplier_info

避免使用：
- vendor（除非特指零售商）
- dealer（除非特指经销商）
- seller（除非特指卖家）
```

#### 结论
在企业级应用中，使用 Supplier 这个术语更能准确表达供应商的专业性、稳定性和长期合作的特点，因此我们在代码中统一使用 Supplier 相关命名。


### 数量的命名

对于形容词/分词修饰的情况，应该使用“形容词+quantity”的形式；对于介词短语修饰的情况，应该使用“quantity+介词短语”的形式。
这样的命名规则更符合英语的语言习惯，也更容易理解和记忆。

当修饰词是形容词/分词时：

```
   allocatedQuantity     // ✓ 更自然
   quantityAllocated    // ✗ 不自然
   
   availableQuantity    // ✓ 更自然
   quantityAvailable    // ✗ 不自然
```

当修饰词是介词短语时：

```
   quantityOnHand      // ✓ 更自然
   onHandQuantity      // ✗ 不自然
   
   quantityInTransit   // ✓ 更自然
   inTransitQuantity   // ✗ 不自然
```

建议，使用形容词/分词修饰时：

```
allocatedQuantity      // "已分配的数量"
reservedQuantity       // "已预留的数量"
availableQuantity      // "可用的数量"
occupiedQuantity       // "被占用的数量"
virtualQuantity        // "虚拟的数量"
```

使用介词短语修饰时：

```
quantityOnHand        // "在手的数量"
quantityInTransit     // "在途的数量"
```

### Bool 类型属性的命名

在命名布尔类型的属性或参数时，确实存在两种常见的模式：
* includeXxx - 表示单个动作
* includesXxx - 表示状态或特性

一般来说：
* 当作为动词使用时（表示一个动作或命令），用单数形式 include
* 当作为形容词使用时（表示一种状态或特性），用第三人称单数 includes

在 REST API 的查询参数中，我建议使用 includes 形式，因为它更符合"描述特性"的语义。这也是很多框架的惯例，比如：

* hasPermission
* containsKey
* includesGraphData


## Domain Operations（领域操作）

> One has an intuitive feeling that data precede algorithms: you must have some objects before you can perform operations on them.
> *Niklaus Wirth, “Algorithms + Data Structures = Programs”, preface, p. xiii*


下面这部分内容是在上文的数据模型设计的基础上进一步讨论更具体的业务操作逻辑。


### 采购订单 / 收货单匹配

#### 关于收货数量的问题

我们先讨论一下“以哪个数量为准”的问题。

在我们的产品（包括 Raw Item）中，存在以下属性：

```yaml
      QuantityUomId: # 主计量单位的 ID，比如“oz”
        type: id
      QuantityIncluded: # 一件（piece）的数量（以“主计量单位”计算）
        description: If you have a six-pack of 12oz soda cans you would have quantityIncluded=12, quantityUomId=oz, piecesIncluded=6.
        type: fixed-point
      PiecesIncluded: # 一个包装（case）包含的“件数”，如果包装内没有“分件”，则该值设置为 1
        type: numeric
```

一般而言，订单、财务核算等通常使用的是以“主计量单位”计算的数量。

但是我们允许在装运（收货）时，前端输入“包装数”，并且由前端自动计算出“主计量单位”下的数量，后端则将两个数量都保存到数据库中。

我们的 `ShipmentReceipt` 实体中，存在以下属性：

```yaml
      QuantityAccepted:
        type: fixed-point
        columnName: QUANTITY_ACCEPTED
      QuantityRejected:
        type: fixed-point
        columnName: QUANTITY_REJECTED
      # ...
      CasesAccepted:
        description: The number of cases accepted
        type: numeric
      CasesRejected:
        description: The number of cases rejected
        type: numeric
```


> 这里有个和“数量”相关的 UI 设计问题可能需要讨论一下：
> 
> - 设计稿在录入订单行项的时候，录入了“包装数”（和收货界面的设计类似）。但是按照经验，感觉下订单的时候一般应该都是按照产品的“主计量单位”录入的。所以这个字段可能是不需要的。
> - 在收货单界面的“行项”信息中，设计稿在显示未收货数量（Outstanding PO quantity）的地方，包含了“（未收货的）包装数”。如果订单行项中没有包装数，则这个未收货包装数应该也是不需要的。


#### 收货单行项和订单行项的匹配处理

##### 异步处理

将“收货单”的行项和订单行项相匹配的事情，这个估计要“异步”处理。原因：
- 我们允许无 PO 收货；
- 如果在收货时使用同步方式做这个匹配可能会降低接口的响应速度，体验比较差。


##### 行项的“数量分配”问题

假设有某个订单有以下订单行项：

| 序号 | 产品(Item) | 数量 |
|------|------------|------|
| 1    | RAW_001    | 100  |
| 2    | RAW_001    | 200  |
| 3    | RAW_002    | 134  |
| 4    | RAW_003    | 203  |

> 先不要纠结为什么同一个产品会分成两行，有很多业务上的理由可能会导致这个结果（比如不同的价格、交货日期等）；并且 PO 什么样也不是我们系统可以决定的。

这是一个收货单的行项：

| 序号 | 产品(Item) | 批次(Lot) | 数量 |
|------|------------|-----------|------|
| 1    | RAW_001    | BATCH001  | 119  |
| 2    | RAW_002    | BATCH002  | 138  |
| 3    | RAW_003    | BATCH003  | 214  |

假设先最简单的情况，每个收货单只收一个订单的货（而现实中几乎一定会出现一次收多个订单的货），我们想要将收货单的行项和订单行项进行匹配。

以 RAW_001 的收货记录为例（BATCH001，数量 119），这一个收货行其实分配方法就有多种。
- 其中一种是拆分分配：分配给订单第 1 行 100，分配给订单第 2 行 19。
- 另一种是整体分配：全部数量 119 都分配给订单第 2 行。

这两种分配方法，在界面上呈现的结果就会不同：

- 第一种分配方法，订单的第一行满足了，第二行没有满足（部分满足）；
- 第二种分配方法，订单的两行都没有满足。

记录“行项/数量分配”信息的表（或者说“实体”）在系统中是存在的。
如果把这个概念呈现给用户——这需要用户去理解这个概念——就可以解释“为什么结果是这样”；
如果把这个东西隐藏起来，虽然降低了界面复杂度，但可能引起用户的困惑。

所以显示/隐藏“分配”的细节，利弊分别是什么，这其实是需要从产品设计角度考量的。


#### 一个订单行项与收货单行项的分配方案

下面是一个可能的订单行项与收货单行项分配方案，我们主要使用类 Java 的伪代码来阐述。

假设实体模型如下：

```java
@Entity
class OrderLine {
    @Id
    String orderLineId; // 订单行ID
    String productId; // 产品ID
    BigDecimal quantity; // 订购数量
}

@Entity
class ReceiptLine {
    @Id
    String receiptLineId; // 收货单行ID
    String productId; // 产品ID
    String lotNumber; // 批次号
    BigDecimal quantity; // 收货数量
}

@Entity
class AllocationResult {
    @Id
    String orderLineId; // 订单行ID
    @Id
    String receiptLineId; // 收货单行ID
    BigDecimal quantityAllocated; // 分配数量
}
```

下面的分配方法的大致设计思路:
- 按产品 ID 对收货行和订单行进行分组匹配。
- 对每个产品使用贪心策略进行分配，尽量减少拆分。
- 记录所有分配结果。

```java
/**
 * 分配结果包装类
 */
@Data
@Builder
public class AllocationResultWrapper {
    // 成功分配的结果
    private List<AllocationResult> allocatedResults;
    
    // 未分配完的收货行及其未分配数量
    private List<UnallocatedReceipt> unallocatedReceipts;
}

/**
 * 未分配完的收货记录
 */
@Data
@Builder
public class UnallocatedReceipt {
    private String receiptLineId;      // 收货行ID
    private String productId;          // 产品ID
    private String lotNumber;          // 批次号
    private BigDecimal totalQuantity;  // 总数量
    private BigDecimal allocatedQuantity;    // 已分配数量
    private BigDecimal unallocatedQuantity;  // 未分配数量
}

@Service
public class ReceiptAllocationService {
    
    /**
     * 为收货行集合分配订单行
     */
    public AllocationResultWrapper allocateReceipts(
            List<ReceiptLine> receiptLines,
            List<OrderLine> orderLines) {

        List<AllocationResult> allocatedResults = new ArrayList<>();
        List<UnallocatedReceipt> unallocatedReceipts = new ArrayList<>();
        
        // 1. 按产品ID分组
        Map<String, List<OrderLine>> orderLinesByProduct = orderLines.stream()
                .collect(Collectors.groupingBy(OrderLine::getProductId));
                
        Map<String, List<ReceiptLine>> receiptLinesByProduct = receiptLines.stream()
                .collect(Collectors.groupingBy(ReceiptLine::getProductId));
        
        // 2. 对每个产品进行分配
        for (String productId : receiptLinesByProduct.keySet()) {
            List<OrderLine> matchedOrderLines = orderLinesByProduct.get(productId);
            List<ReceiptLine> matchedReceiptLines = receiptLinesByProduct.get(productId);
            
            // 如果没有匹配的订单行,将所有收货行标记为未分配
            if (matchedOrderLines == null || matchedOrderLines.isEmpty()) {
                matchedReceiptLines.forEach(receiptLine -> 
                    unallocatedReceipts.add(UnallocatedReceipt.builder()
                        .receiptLineId(receiptLine.getReceiptLineId())
                        .productId(receiptLine.getProductId())
                        .lotNumber(receiptLine.getLotNumber())
                        .totalQuantity(receiptLine.getQuantity())
                        .allocatedQuantity(BigDecimal.ZERO)
                        .unallocatedQuantity(receiptLine.getQuantity())
                        .build())
                );
                continue;
            }
            
            // 执行分配并获取结果
            ProductAllocationResult productResult = 
                allocateByProduct(matchedOrderLines, matchedReceiptLines);
            
            allocatedResults.addAll(productResult.getAllocatedResults());
            unallocatedReceipts.addAll(productResult.getUnallocatedReceipts());
        }
        
        return AllocationResultWrapper.builder()
                .allocatedResults(allocatedResults)
                .unallocatedReceipts(unallocatedReceipts)
                .build();
    }
    
    @Data
    @Builder
    private static class ProductAllocationResult {
        private List<AllocationResult> allocatedResults;
        private List<UnallocatedReceipt> unallocatedReceipts;
    }
    
    /**
     * 对单个产品的收货行和订单行进行分配
     */
    private ProductAllocationResult allocateByProduct(
            List<OrderLine> orderLines,
            List<ReceiptLine> receiptLines) {
            
        List<AllocationResult> allocatedResults = new ArrayList<>();
        List<UnallocatedReceipt> unallocatedReceipts = new ArrayList<>();
        
        // 1. 计算订单行可用总量
        BigDecimal totalOrderQuantity = orderLines.stream()
                .map(OrderLine::getQuantity)
                .reduce(BigDecimal.ZERO, BigDecimal::add);
        
        // 2. 记录每个订单行的已分配数量
        Map<String, BigDecimal> allocatedQtyByOrderLine = new HashMap<>();
        
        // 3. 记录每个收货行的已分配数量
        Map<String, BigDecimal> allocatedQtyByReceiptLine = new HashMap<>();
        
        // 4. 对收货行按数量降序排序(优先分配大批量收货)
        receiptLines.sort((a, b) -> b.getQuantity().compareTo(a.getQuantity()));
        
        // 5. 对每个收货行进行分配
        for (ReceiptLine receiptLine : receiptLines) {
            BigDecimal remainingQty = receiptLine.getQuantity();
            BigDecimal allocatedQty = BigDecimal.ZERO;
            
            // 找出未完全分配的订单行
            List<OrderLine> availableOrderLines = orderLines.stream()
                .filter(orderLine -> {
                    BigDecimal allocated = allocatedQtyByOrderLine
                        .getOrDefault(orderLine.getOrderLineId(), BigDecimal.ZERO);
                    return allocated.compareTo(orderLine.getQuantity()) < 0;
                })
                .sorted((a, b) -> {
                    // 按未分配数量降序排序
                    BigDecimal outstandingA = a.getQuantity()
                        .subtract(allocatedQtyByOrderLine
                            .getOrDefault(a.getOrderLineId(), BigDecimal.ZERO));
                    BigDecimal outstandingB = b.getQuantity()
                        .subtract(allocatedQtyByOrderLine
                            .getOrDefault(b.getOrderLineId(), BigDecimal.ZERO));
                    return outstandingB.compareTo(outstandingA);
                })
                .collect(Collectors.toList());
                
            // 对当前收货行进行分配
            for (OrderLine orderLine : availableOrderLines) {
                if (remainingQty.compareTo(BigDecimal.ZERO) <= 0) {
                    break;
                }
                
                BigDecimal allocated = allocatedQtyByOrderLine
                    .getOrDefault(orderLine.getOrderLineId(), BigDecimal.ZERO);
                BigDecimal outstanding = orderLine.getQuantity().subtract(allocated);
                
                // 计算本次分配数量
                BigDecimal allocateQty = outstanding.min(remainingQty);
                
                // 记录分配结果
                allocatedResults.add(new AllocationResult(
                    orderLine.getOrderLineId(),
                    receiptLine.getReceiptLineId(),
                    allocateQty
                ));
                
                // 更新已分配数量
                allocatedQtyByOrderLine.merge(
                    orderLine.getOrderLineId(),
                    allocateQty,
                    BigDecimal::add
                );
                
                allocatedQty = allocatedQty.add(allocateQty);
                remainingQty = remainingQty.subtract(allocateQty);
            }
            
            // 记录未分配完的收货数量
            if (remainingQty.compareTo(BigDecimal.ZERO) > 0) {
                unallocatedReceipts.add(UnallocatedReceipt.builder()
                    .receiptLineId(receiptLine.getReceiptLineId())
                    .productId(receiptLine.getProductId())
                    .lotNumber(receiptLine.getLotNumber())
                    .totalQuantity(receiptLine.getQuantity())
                    .allocatedQuantity(allocatedQty)
                    .unallocatedQuantity(remainingQty)
                    .build());
            }
        }
        
        return ProductAllocationResult.builder()
                .allocatedResults(allocatedResults)
                .unallocatedReceipts(unallocatedReceipts)
                .build();
    }
}
```


### 需求数量和履行数量分配方案的泛化

#### 问题描述

让我们再次考虑一下上面提到的“订单行与收货单行分配”的问题，它其实是一个“需求数量和履行数量分配”的问题。

> 这里我们可以先不关注上面讨论中给出的示例伪代码中的那个“产品分组”方法，我们先主要关注“产品匹配”后的数量分配方法。

同样的问题在其他场景中也会出现，例如：

1. 采购订单收货：将收货单行项的数量分配给采购订单行项
2. 销售订单发货：将发货单行项的数量分配给销售订单行项
3. 生产订单完工：将完工数量分配给生产订单行项

这些场景具有共同的特点：
- 都涉及两种类型的行项：需求方和履行方
- 都需要处理数量的分配
- 都可能出现未完全分配的情况


#### 设计思考

##### 抽象概念

我们可以将这些场景抽象为以下核心概念：

1. **需求行项(Demand Line)**
   - 表示对某种产品/服务的需求
   - 包含需求数量
   - 例如：订单行项

2. **履行行项(Fulfillment Line)**
   - 表示实际作业的结果
   - 包含实际数量
   - 例如：收货单行项、发货单行项

3. **分配结果(Allocation Result)**
   - 记录需求行项和履行行项之间的数量分配关系
   - 包含已分配数量
   - 可能包含未分配完的履行数量

##### 通用性考虑

为了使设计具有更好的通用性：

1. 使用泛型处理行项 ID
   - 不同系统可能使用不同类型的 ID（String、Long、UUID 等）
   - 使用泛型可以提供类型安全

2. 接口设计要足够抽象
   - 不涉及具体业务逻辑
   - 便于不同场景复用

#### 解决方案

##### 核心接口定义

```java
/**
 * 表示一个数量需求行项
 * @param <D> 需求行项 ID 的类型
 */
public interface QuantityDemandLine<D> {
    D getDemandLineId();  // 需求行项ID
    BigDecimal getDemandedQuantity();  // 需求数量
}

/**
 * 表示一个实际作业行项
 * @param <F> 作业行项 ID 的类型
 */
public interface QuantityFulfillmentLine<F> {
    F getFulfillmentLineId();  // 作业行项ID
    BigDecimal getFulfilledQuantity();  // 作业数量
}

/**
 * 分配结果
 * @param <D> 需求行项 ID 的类型
 * @param <F> 作业行项 ID 的类型
 */
public interface AllocationResult<D, F> {
    D getDemandLineId();
    F getFulfillmentLineId();
    BigDecimal getAllocatedQuantity();
}

/**
 * 未分配完的作业行项
 * @param <F> 作业行项 ID 的类型
 */
public interface UnallocatedFulfillment<F> {
    F getFulfillmentLineId();
    BigDecimal getTotalQuantity();
    BigDecimal getAllocatedQuantity();
    BigDecimal getUnallocatedQuantity();
}

/**
 * 分配结果包装器
 * @param <D> 需求行项ID的类型
 * @param <F> 作业行项ID的类型
 */
public interface AllocationResultWrapper<D, F> {
    List<AllocationResult<D, F>> getAllocatedResults();
    List<UnallocatedFulfillment<F>> getUnallocatedFulfillments();
}

/**
 * 数量分配服务
 * @param <D> 需求行项 ID 的类型
 * @param <F> 作业行项 ID 的类型
 */
public interface QuantityAllocationService<D, F> {
    /**
     * 将实际作业行项分配给需求行项
     *
     * @param fulfillmentLines 实际作业行项集合
     * @param demandLines 需求行项集合
     * @return 分配结果
     */
    AllocationResultWrapper<D, F> allocateQuantities(
        List<QuantityFulfillmentLine<F>> fulfillmentLines,
        List<QuantityDemandLine<D>> demandLines
    );
}
```

##### 使用示例

```java
// 订单行实现需求行项接口
class OrderLine implements QuantityDemandLine<String> {
    private String orderLineId;
    private BigDecimal quantity;
    
    @Override
    public String getDemandLineId() {
        return orderLineId;
    }
    
    @Override
    public BigDecimal getDemandedQuantity() {
        return quantity;
    }
}

// 收货行实现履行行项接口
class ReceiptLine implements QuantityFulfillmentLine<String> {
    private String receiptLineId;
    private BigDecimal quantity;
    
    @Override
    public String getFulfillmentLineId() {
        return receiptLineId;
    }
    
    @Override
    public BigDecimal getFulfilledQuantity() {
        return quantity;
    }
}

// 使用分配服务
QuantityAllocationService<String, String> service = new QuantityAllocationServiceImpl<>();
AllocationResultWrapper<String, String> result = service.allocateQuantities(
    receiptLines, 
    orderLines
);
```

#### 设计优点

1. **通用性**
   - 可用于多种业务场景
   - 不与具体业务逻辑耦合

2. **类型安全**
   - 使用泛型确保类型安全
   - 在编译时发现类型问题

3. **完整性**
   - 包含完整的分配结果
   - 跟踪未分配的数量

4. **灵活性**
   - 支持不同类型的ID
   - 易于扩展新的实现

5. **清晰性**
   - 接口命名符合领域语言
   - 职责划分明确

#### 应用场景

1. **采购订单收货**
```java
QuantityAllocationService<PurchaseOrderLineId, ReceiptLineId>
```

2. **销售订单发货**
```java
QuantityAllocationService<SalesOrderLineId, ShipmentLineId>
```

3. **生产订单完工**
```java
QuantityAllocationService<ProductionOrderLineId, CompletionLineId>
```

#### 后续扩展

可以考虑：

1. 添加更多的分配策略。
   1. 我们可以根据具体的分配策略来命名分配服务实现类。比如之前提供的示例代码所采用的贪心策略，实现类可以命名为 `GreedyQuantityAllocationService`。
   2. 支持业务人员“手动分配”，然后在此基础上系统进行自动分配。
2. 增加批次号等其他维度的匹配。



