# 实体模型设计（草稿）


Tips：

- 模型设计可部分参考 WMS 代码库的分支：`rfid-demo-1`。
  - 该分支 2019 年时为了做“追溯项目”的前期 demo 做过较多有针对性的修改（相对青岛 WMS 系统）。
  - 继续将 WMS 之前的 `AttributeSet` / `AttributeSetInstance` 的设计引入追溯项目——但是会做一些重要的改进。

- 关于 Order 和 Shipment（包括收货类型的 Shipment）之间的关系，参考模型：
  - 《使用 DSL 实现领域驱动设计》- 第四部分 - 数据建模示例：订单的装运与支付；

- 关于业务实体相关模型的设计原则：
  - 《使用 DSL 实现领域驱动设计》- 第四部分 - 不要用“我”的视角去设计核心模型。

- QA 相关模型的设计。
  - 参考 AI 推荐的模型，但是做一些简化。比如，检验方案（scheme）这个阶段似乎没有必要。可以考虑使用：检验单、检验行（InspectionItem）、检查项目（CheckItem）。
  - 将“检验单”主要关联到产品和批次号。（与其他实体的关联的“外键”都允许为空。）


## 处理“编码缺失”

对于作业中可能存在“编码缺失”情况的实体——也就是可能无法获取“标准化”的“领域 ID”的实体：
- 应用给予“内部编码”，作为实体的 Id（key）先保存到数据库中。
- 通过附加的 `XxxIdentification` 实体来实现“编码映射”。
  - 可以通过事后“补录”编码映射的方式来实现“标准化”。
  - 在存在“标准化”的编码映射时，前端显示“标准化”的编码，否则显示“内部编码”。
- 下面讨论了一些例子：
  - `Product` / `GoodIdentification`；
  - `Lot` / `LotIdentification`；
  - `Party` / `PartyIdentification`;
  - `Facility` / `FacilityIdentification` 等。


## 不完整总结：追溯系统可能用到的实体

### 业务主体相关 / 供应商管理

* Party
* PartyRole
* PartyIdentification


### 产品相关 / 原材料管理

* Product
* ProductCategory
* ProductCategoryMember
* GoodIdentification
* Uom


### 设施 / 仓库管理

* Facility
* FacilityLocation


### 订单相关 / 采购订单管理

* Order
* OrderItem


### 装运相关 / 收货（Receiving）管理

* Shipment
* ShipmentItem
* ShipmentReceipt
* Document


### 库存相关 / 产品（托盘等）标签管理

* InventoryItem
* InventoryItemEntry（or InventoryItemDetail）
* AttributeSet
* AttributeSetInstance
* Lot

### QA / 质量管理

* QaInspection
* QaInspectionItem
* QaCheckItem

### 文档 / 文件管理

* Document


### 用户认证 / 授权相关

在 Spring Security 以及 Spring Authorization Server 的基础上进行改进。
默认的 Schema（见本文末尾）可能不能完全满足这些需求，需要做一些改进：

- 首次登录后必须修改密码
- 密码有效期 3 个月，超期自动提醒更改
- ~~冻结用户（似乎可以用 enable 列）~~

基于 Spring Authorization Server 开发一个独立的 OAuth Service 来给用户进行认证和授权（基于 JWT）。

其他后端服务依赖 Spring Authorization Server 的 Resource Server 包来解析和验证 JWT。


### CTE / KDE 相关

见代码库的 dddml 目录中的已有模型（这些模型是 DDDML 描述的 DDD 风格的 OO 模型）。


---

以下是对参考实体模型（主要来自于 OFBiz 与 WMS）的分析：


## InventoryItem 实体

OFBiz 的 InventoryItem 模型定义（OFBiz 的模型是“实体-关系”模型）：

```xml
    <entity entity-name="InventoryItem"
            package-name="org.apache.ofbiz.product.inventory"
            title="Inventory Item">
      <field name="inventoryItemId" type="id"></field>
      <field name="inventoryItemTypeId" type="id"></field>
      <field name="productId" type="id"></field>
      <field name="partyId" type="id"></field>
      <field name="ownerPartyId" type="id"><description>The owner of the inventory item.</description></field>
      <field name="statusId" type="id"></field>
      <field name="datetimeReceived" type="date-time"></field>
      <field name="datetimeManufactured" type="date-time"></field>
      <field name="expireDate" type="date-time"></field>
      <field name="facilityId" type="id"></field>
      <field name="containerId" type="id"></field>
      <field name="lotId" type="id"></field>
      <field name="uomId" type="id"></field>
      <field name="binNumber" type="id"></field>
      <field name="locationSeqId" type="id"></field>
      <field name="comments" type="comment"></field>
      <field name="quantityOnHandTotal" type="fixed-point"></field>
      <field name="availableToPromiseTotal" type="fixed-point"></field>
      <field name="accountingQuantityTotal" type="fixed-point"></field>
      <field name="serialNumber" type="value"></field>
      <field name="softIdentifier" type="value"></field>
      <field name="activationNumber" type="value"></field>
      <field name="activationValidThru" type="date-time"></field>
      <field name="unitCost" type="fixed-point"><description>Higher precision in case it is a calculated number</description></field>
      <field name="currencyUomId" type="id"><description>The currency Uom of the unit cost.</description></field>
      <field name="fixedAssetId" type="id"></field>
      <prim-key field="inventoryItemId"/>
      <relation type="one" fk-name="INV_ITEM_TYPE" rel-entity-name="InventoryItemType">
        <key-map field-name="inventoryItemTypeId"/>
      </relation>
      <relation type="many" rel-entity-name="InventoryItemTypeAttr">
        <key-map field-name="inventoryItemTypeId"/>
      </relation>
      <relation type="one" fk-name="INV_ITEM_CONTAINER" rel-entity-name="Container">
        <key-map field-name="containerId"/>
      </relation>
      <relation type="one" fk-name="INV_ITEM_LOT" rel-entity-name="Lot">
        <key-map field-name="lotId"/>
      </relation>
      <relation type="one-nofk" rel-entity-name="ProductFacility">
        <key-map field-name="productId"/>
        <key-map field-name="facilityId"/>
      </relation>
      <relation type="one-nofk" rel-entity-name="FacilityLocation">
        <key-map field-name="facilityId"/>
        <key-map field-name="locationSeqId"/>
      </relation>
      <relation type="one-nofk" rel-entity-name="ProductFacilityLocation">
        <key-map field-name="productId"/>
        <key-map field-name="facilityId"/>
        <key-map field-name="locationSeqId"/>
      </relation>
      <relation type="one" fk-name="IYIM_FAST" title="FixedAsset" rel-entity-name="FixedAsset">
        <key-map field-name="fixedAssetId"/>
      </relation>
      <!-- 其他关系略 -->
      <index name="INVITEM_SOFID" unique="true">
        <index-field name="softIdentifier"/>
      </index>
      <index name="INVITEM_ACTNM" unique="true">
        <index-field name="activationNumber"/>
      </index>
      <index name="INV_ITEM_SN">
        <index-field name="serialNumber"/>
      </index>
    </entity>
```

InventoryItem 是库存项目实体，用于跟踪和管理仓库中的具体库存项目。让我们详细分析每个字段：

### 1. 基本标识字段

- `inventoryItemId`: 库存项目的唯一标识符
- `inventoryItemTypeId`: 库存项目类型标识符（如：成品、原材料、在制品等）
- `productId`: 关联的产品标识符
- `serialNumber`: 序列号，用于唯一标识特定的产品实例
- `softIdentifier`: 软标识符，可用于额外的产品识别信息
- `binNumber`: 库位号，表示货物在仓库中的具体存放位置

### 2. 组织和所有权字段

- `partyId`: 相关方ID（可能是供应商、客户等）
- `ownerPartyId`: 库存项目的所有者ID
  - 描述：`The owner of the inventory item`
  - 在寄售、代销等业务场景中特别重要

### 3. 位置和存储信息

- `facilityId`: 仓储设施ID（仓库标识）
- `containerId`: 容器ID（如：托盘、箱子等）
- `locationSeqId`: 位置序列ID（具体货架位置）
- `lotId`: 批次ID，用于批次管理和追踪

### 4. 数量相关字段

- `quantityOnHandTotal`: 实际库存总量
- `availableToPromiseTotal`: 可承诺数量总计
  - 表示可以用于销售或承诺给客户的数量
  - 通常小于或等于实际库存量
- `accountingQuantityTotal`: 会计核算数量总计
- `uomId`: 计量单位ID（如：个、箱、千克等）

### 5. 时间相关字段

- `datetimeReceived`: 接收时间
- `datetimeManufactured`: 生产制造时间
- `expireDate`: 过期日期
- `activationValidThru`: 激活有效期

### 6. 成本和货币字段

- `unitCost`: 单位成本
  - 描述：`Higher precision in case it is a calculated number`
  - 使用高精度以支持计算值
- `currencyUomId`: 货币单位ID
  - 描述：`The currency Uom of the unit cost`
  - 用于标识单位成本的货币类型

### 7. 状态和追踪字段

- `statusId`: 状态ID（如：可用、已预留、已报废等）
- `activationNumber`: 激活号码
- `fixedAssetId`: 固定资产ID
- `comments`: 备注信息

### 8. 业务应用场景

1. **库存管理**
   - 通过 `quantityOnHandTotal` 和 `availableToPromiseTotal` 进行库存控制
   - 使用 `lotId` 和 `serialNumber` 进行批次和序列号管理

2. **仓储操作**
   - 利用 `facilityId`、`containerId` 和 `locationSeqId` 进行仓储定位
   - 通过 `binNumber` 实现精确的库位管理

3. **效期管理**
   - 使用 `expireDate` 进行产品效期管理
   - 结合 `datetimeManufactured` 追踪产品生命周期

4. **成本核算**
   - 通过 `unitCost` 和 `currencyUomId` 进行成本管理
   - 使用 `accountingQuantityTotal` 支持财务核算

5. **所有权管理**
   - 通过 `ownerPartyId` 和 `partyId` 管理库存所有权
   - 支持寄售、代销等特殊业务模式

### 9. 注意事项

1. **数量字段管理**
   - 需要确保 `quantityOnHandTotal` ≥ `availableToPromiseTotal`
   - `accountingQuantityTotal` 应与实际库存量保持一致

2. **位置信息完整性**
   - `facilityId`、`locationSeqId` 和 `binNumber` 应形成完整的位置信息链
   - 确保位置信息的准确性和可追溯性

3. **时间字段维护**
   - 及时更新 `datetimeReceived` 和 `datetimeManufactured`
   - 定期检查 `expireDate` 以进行库存效期管理

---

在 OFBiz 中，InventoryItem 实体的数量属性包括：

* `quantityOnHandTotal`。在库数量。
* `availableToPromiseTotal`。可承诺数量。（可销售数量、可发货数量）
* `accountingQuantityTotal`。会计核算数量。


在之前的 WMS 中，InventoryItem 实体的数量属性包括：

```yaml
        # 在库数量
        OnHandQuantity:
          type: decimal
        # 在途数量
        InTransitQuantity:
          type: decimal
        # 保留数量
        ReservedQuantity:
          type: decimal
        # 占用数量
        OccupiedQuantity:
          type: decimal
        # 虚拟数量
        VirtualQuantity:
          type: decimal
```

### 考虑 InventoryItem 实体的“数量”属性的命名改进

##### OFBiz 的命名方式
- `quantityOnHandTotal`（在库数量）
- `availableToPromiseTotal`（可承诺数量）
- `accountingQuantityTotal`（会计核算数量）

##### 原 WMS 的命名方式

```yaml
        # 在库数量
        OnHandQuantity:
          type: decimal
        # 在途数量
        InTransitQuantity:
          type: decimal
        # 保留数量
        ReservedQuantity:
          type: decimal
        # 占用数量
        OccupiedQuantity:
          type: decimal
        # 虚拟数量
        VirtualQuantity:
          type: decimal
```


#### 为什么 `quantityOnHand` 比 `onHandQuantity` 更好？

1. **符合 Java 命名惯例**
   - Java 倾向于"名词在前，修饰词在后"的命名方式
   - 与 Java 标准库的命名风格一致（如 `timeInMillis`）

2. **更好的代码组织**
   - 所有数量相关的字段都以 quantity 开头
   - 便于 IDE 中的代码补全和查找
   - 相关属性自然分组

3. **面向对象思维**
   - quantity 是主体（名词）
   - onHand 是其修饰词（描述性质）

#### 建议的命名修改

原 WMS 的 YAML 定义应修改为：

```yaml
        # 在库数量
        quantityOnHand:
          type: decimal
        # 在途数量
        quantityInTransit:
          type: decimal
        # 保留数量
        quantityReserved:
          type: decimal
        # 占用数量
        quantityOccupied:
          type: decimal
        # 虚拟数量
        quantityVirtual:
          type: decimal
```

### 对 WMS InventoryItem 实体 Id 的改进考虑

当前的 InventoryItem 实体的“领域 ID”的类型为：

```yaml
        InventoryItemId:
          properties:
            # 产品 Id
            ProductId:
              type: id-long
              columnName: ProductId
              length: 60
            # 货位 Id.
            LocatorId: 
              type: string
              columnName: LocatorId
              length: 50
            # 属性集实例 Id.
            AttributeSetInstanceId:
              type: string
              columnName: AttributeSetInstanceId
              length: 50
```

如果想要更“偏向”OFBiz 的实体模型的设计，可以考虑改为：

```yaml
        InventoryItemId:
          properties:
            ProductId:
              type: id-long
            # 考虑弃用 Locator 实体，改为使用 Facility 与 FacilityLocation 实体
            FacilityId:
              type: id
            LocationSeqId:
              type: id
            AttributeSetInstanceId:
              type: id-long
              #c1913514d984b1e2839bea485ed5a3ec
```

这样做的好处是：可以更多地“直接利用”OFBiz 的 Facility 实体和 FacilityLocation 实体的设计。

除了领域 Id（复合 ID）之外的其他 OFBiz 库存单元的属性，比如 `fixedAssetId`、`lotId`、`serialNumber`、`softIdentifier`、`activationNumber` 等，
都可以考虑放到 AttributeSetInstance 实体中。

### 对 AttributeSetInstance 的改进考虑

我们可以考虑将 `AttributeSetInstance` 实现为一个 `Map<String, Object>`，数据库的持久化类型为 `JSONB` 或者 `JSON`，可以充分满足可扩展性的要求。

这也是为什么我们建议使用 PostgreSQL 数据库的原因之一。因为 PostgreSQL 对 JSONB/JSON 列类型的支持是比较好的。

给 AttributeSetInstance 预先定义一些 Key（或者说 AttributeId）常量。
这些 Key 支持“可配置”，前端可以显示这些 Key 的“描述”；后端对 Key / Value 的合法性进行检查。
比如：

* CaseGTIN:
  * description: "AI (01) Case GTIN"
* CaseBatch:
  * description: "AI (10) Case Batch/Lot"
* PalletSSCC:
  * description: "AI (00) Pallet SSCC"
* PackDate:
  * description: "AI (13) Pack Date"
* HarvestDate:
  * description: "AI (13) Harvest Date"
* BestIfUsedByDate:
  * description: "AI (15) Best if Used by Date"
* SerialNumber:
  * description: "AI (21) Serial Number"

考虑 Attribute 支持更多的“类型”，比如似乎有必要支持 OffsetDateTime 等。


## InventoryItemDetail 实体

OFBiz 的 InventoryItemDetail 实体定义：

```xml
    <entity entity-name="InventoryItemDetail"
            package-name="org.apache.ofbiz.product.inventory"
            title="Inventory Item Detail">
      <field name="inventoryItemId" type="id"></field>
      <field name="inventoryItemDetailSeqId" type="id"></field>
      <field name="effectiveDate" type="date-time"></field>
      <field name="quantityOnHandDiff" type="fixed-point"></field>
      <field name="availableToPromiseDiff" type="fixed-point"></field>
      <field name="accountingQuantityDiff" type="fixed-point"></field>
      <field name="unitCost" type="fixed-point"></field>
      <field name="orderId" type="id"></field>
      <field name="orderItemSeqId" type="id"></field>
      <field name="shipGroupSeqId" type="id"></field>
      <field name="shipmentId" type="id"></field>
      <field name="shipmentItemSeqId" type="id"></field>
      <field name="returnId" type="id"></field>
      <field name="returnItemSeqId" type="id"></field>
      <field name="workEffortId" type="id"></field>
      <field name="fixedAssetId" type="id"></field>
      <field name="maintHistSeqId" type="id"></field>
      <field name="itemIssuanceId" type="id"></field>
      <field name="receiptId" type="id"></field>
      <field name="physicalInventoryId" type="id"></field>
      <field name="reasonEnumId" type="id"></field>
      <field name="description" type="description"></field>
      <prim-key field="inventoryItemId"/>
      <prim-key field="inventoryItemDetailSeqId"/>
      <relation type="one" fk-name="INV_ITDTL_ITMIS" rel-entity-name="ItemIssuance">
        <key-map field-name="itemIssuanceId"/>
      </relation>
      <relation type="one-nofk" rel-entity-name="WorkEffortInventoryAssign">
        <key-map field-name="workEffortId"/>
        <key-map field-name="inventoryItemId"/>
      </relation>
      <relation type="one-nofk" rel-entity-name="WorkEffortInventoryProduced">
        <key-map field-name="workEffortId"/>
        <key-map field-name="inventoryItemId"/>
      </relation>
      <relation type="one" fk-name="INV_ITDTL_SHRCT" rel-entity-name="ShipmentReceipt">
        <key-map field-name="receiptId"/>
      </relation>
      <relation type="one" fk-name="INV_ITDTL_PHINV" rel-entity-name="PhysicalInventory">
        <key-map field-name="physicalInventoryId"/>
      </relation>
      <relation title="Reason" fk-name="INV_ITDTL_REAS" rel-entity-name="Enumeration" type="one">
        <key-map field-name="reasonEnumId" rel-field-name="enumId"/>
      </relation>
      <relation type="one-nofk" rel-entity-name="InventoryItemVariance">
        <key-map field-name="inventoryItemId"/>
        <key-map field-name="physicalInventoryId"/>
      </relation>
      <!-- 其他关系略 -->
    </entity>
```

从中我们也可以看出 OFBiz 考虑到哪些“单据”可能会影响库存的变化。比如装运单（`shipmentId`）、退货单（`returnId`）、工作单（`workEffortId`）、盘点单（`physicalInventoryId`）等。

---

对比一下原 WMS 的 InventoryItemEntry 实体的定义：

```yaml
aggregates:
    InventoryItem:
      id:
        name: InventoryItemId
        type: InventoryItemId
      properties:
        # 数量相关属性略

        # 库存事务条目（分录）
        Entries:
          itemType: InventoryItemEntry
          
        InventoryItemIdentifications:
          itemType: InventoryItemIdentification
      
      entities:
        # --------------- 库存事务条目（分录） ------------------
        InventoryItemEntry:
          immutable: true
          id:
            name: EntrySeqId
            type: long
            columnName: EntrySeqId
          properties:
            # 在库数量（变化），命名考虑改为 quantityOnHandDelta
            OnHandQuantity:
              type: decimal
            # 在途数量（变化），命名考虑改为 quantityInTransitDelta
            InTransitQuantity:
              type: decimal
            # 保留数量（变化），命名考虑改为 quantityReservedDelta
            ReservedQuantity:
              type: decimal
            # 占用数量（变化），命名考虑改为 quantityOccupiedDelta
            OccupiedQuantity:
              type: decimal
            # 虚拟数量（变化），命名考虑改为 quantityVirtualDelta
            VirtualQuantity:
              type: decimal
            # 来源信息
            Source:
              type: InventoryItemSourceInfo
              notNull: true
            # 库存事务（交易）的发生时间
            OccurredAt:
              type: date-time
              notNull: true
          # 唯一约束
          uniqueConstraints:
            # 一个“来源”不能重复产生库存事务（分录）
            UniqueInventoryItemSource: [Source]
          # ------------------------------
      
        InventoryItemIdentification:
          id: 
            name: InventoryItemIdentificationTypeId
            type: id-ne            
          properties:
            IdValue:
              type: string
              notNull: true
            Scope:
              type: id
              notNull: true
          uniqueConstraints:
            UniqueInventoryItemId: [Scope, IdValue]
      
      # ---------------- Value Objects -------------------
      valueObjects:      
        #InventoryItemId:
        #  properties:
        #    # 属性略（产品 Id 等）

        # 库存单元来源信息（命名改进一下？比如 InventoryItemEntryDocumentReference）
        InventoryItemSourceInfo:
          properties:
            # 单据类型 Id.
            # Document type identifier.
            DocumentTypeId:
              type: string # id
              referenceType: DocumentType
              notNull: true
            # 单据号
            # Document number.
            DocumentNumber:
              type: string # id-long
              notNull: true
            # 行号
            # Line number.
            LineNumber: # id-long （重命名为 DocumentLine 合适吗？）
              type: string
            # 单据行项的子项（一个源单据行项可能需要产生多个库存事务条目，这个 Id 用于进一步区分这些条目）
            # Sub-identifier for line items
            # (Used to distinguish multiple inventory transaction entries that may be generated from a single source document line item).
            LineSubSeqId:
              type: int # id（也许可以考虑重新命名为 LineSubId）
```

对库存条目（库存单元变动、库存单元明细）的记录，WMS 的方案似乎更具备可扩展性，可以考虑在适当改进后继续使用。


## PhysicalInventory 实体

OFBiz 的 PhysicalInventory（库存盘点）实体定义：

```xml
    <entity entity-name="PhysicalInventory"
            package-name="org.apache.ofbiz.product.inventory"
            title="Physical Inventory">
      <field name="physicalInventoryId" type="id"></field>
      <field name="physicalInventoryDate" type="date-time"></field>
      <field name="partyId" type="id"></field>
      <field name="generalComments" type="comment"></field>
      <prim-key field="physicalInventoryId"/>
    </entity>
```

## InventoryItemVariance 实体

OFBiz 的 InventoryItemVariance（库存差异）实体定义：

```xml
    <entity entity-name="InventoryItemVariance"
            package-name="org.apache.ofbiz.product.inventory"
            title="Inventory Item Variance">
      <field name="inventoryItemId" type="id"></field>
      <field name="physicalInventoryId" type="id"></field>
      <field name="varianceReasonId" type="id"></field>
      <field name="availableToPromiseVar" type="fixed-point"></field>
      <field name="quantityOnHandVar" type="fixed-point"></field>
      <field name="comments" type="comment"></field>
      <prim-key field="inventoryItemId"/>
      <prim-key field="physicalInventoryId"/>
      <relation type="one" fk-name="INV_ITEM_VAR_PINV" rel-entity-name="PhysicalInventory">
        <key-map field-name="physicalInventoryId"/>
      </relation>
      <relation type="one" fk-name="INV_ITEM_VAR_RSN" rel-entity-name="VarianceReason">
        <key-map field-name="varianceReasonId"/>
      </relation>
      <relation type="one" fk-name="INV_ITEM_VAR_ITEM" rel-entity-name="InventoryItem">
        <key-map field-name="inventoryItemId"/>
      </relation>
    </entity>
```

## FacilityLocation 实体

OFBiz 的 FacilityLocation 实体定义：

```xml
    <entity entity-name="FacilityLocation" package-name="org.apache.ofbiz.product.facility" title="Facility Location">
        <field name="facilityId" type="id"></field>
        <field name="locationSeqId" type="id"></field>
        <field name="locationTypeEnumId" type="id"></field>
        <field name="areaId" type="id"></field>
        <field name="aisleId" type="id"></field>
        <field name="sectionId" type="id"></field>
        <field name="levelId" type="id"></field>
        <field name="positionId" type="id"></field>
        <field name="geoPointId" type="id"></field>      
        <prim-key field="facilityId"/>
        <prim-key field="locationSeqId"/>
        <relation type="one" fk-name="FACILITY_LOC_FAC" rel-entity-name="Facility">
            <key-map field-name="facilityId"/>
        </relation>
        <relation type="one" fk-name="FACILITY_LOC_TENM" title="Type" rel-entity-name="Enumeration">
            <key-map field-name="locationTypeEnumId" rel-field-name="enumId"/>
        </relation>
      <relation type="one" fk-name="FACILITY_LOC_GEOPT" rel-entity-name="GeoPoint">
        <key-map field-name="geoPointId"/>
      </relation>      
    </entity>
```


## InventoryTransfer 实体

OFBiz 的 InventoryTransfer 实体定义：

```xml
    <entity entity-name="InventoryTransfer"
            package-name="org.apache.ofbiz.product.inventory"
            title="Inventory Transfer">
      <field name="inventoryTransferId" type="id"></field>
      <field name="statusId" type="id"></field>
      <field name="inventoryItemId" type="id"></field>
      <field name="facilityId" type="id"></field>
      <field name="locationSeqId" type="id"></field>
      <field name="containerId" type="id"></field>
      <field name="facilityIdTo" type="id"></field>
      <field name="locationSeqIdTo" type="id"></field>
      <field name="containerIdTo" type="id"></field>
      <field name="itemIssuanceId" type="id"></field>
      <field name="sendDate" type="date-time"></field>
      <field name="receiveDate" type="date-time"></field>
      <field name="comments" type="comment"></field>
      <prim-key field="inventoryTransferId"/>
      <relation type="one" fk-name="INV_XFER_ITEM" rel-entity-name="InventoryItem">
        <key-map field-name="inventoryItemId"/>
      </relation>
      <relation type="one" fk-name="INV_XFER_STTS" rel-entity-name="StatusItem">
        <key-map field-name="statusId"/>
      </relation>
      <relation type="one" fk-name="INV_XFER_FAC" rel-entity-name="Facility">
        <key-map field-name="facilityId"/>
      </relation>
      <relation type="one-nofk" rel-entity-name="FacilityLocation">
        <key-map field-name="facilityId"/>
        <key-map field-name="locationSeqId"/>
      </relation>
      <relation type="one" fk-name="INV_XFER_CONT" rel-entity-name="Container">
        <key-map field-name="containerId"/>
      </relation>
      <relation type="one" fk-name="INV_XFER_TFAC" title="To" rel-entity-name="Facility">
        <key-map field-name="facilityIdTo" rel-field-name="facilityId"/>
      </relation>
      <relation type="one-nofk" title="To" rel-entity-name="FacilityLocation">
        <key-map field-name="facilityIdTo" rel-field-name="facilityId"/>
        <key-map field-name="locationSeqIdTo" rel-field-name="locationSeqId"/>
      </relation>
      <relation type="one" fk-name="INV_XFER_TCNT" title="To" rel-entity-name="Container">
        <key-map field-name="containerIdTo" rel-field-name="containerId"/>
      </relation>
      <relation type="one" fk-name="INV_XFER_ISSU" rel-entity-name="ItemIssuance">
        <key-map field-name="itemIssuanceId"/>
      </relation>
    </entity>
```

## Shipment 相关实体

### Shipment 实体

OFBiz 的 Shipment 实体定义：

```xml
    <entity entity-name="Shipment"
            package-name="org.apache.ofbiz.shipment.shipment"
            title="Shipment">
      <field name="shipmentId" type="id"></field>
      <field name="shipmentTypeId" type="id"></field>
      <field name="statusId" type="id"></field>
      <field name="primaryOrderId" type="id"></field>
      <field name="primaryReturnId" type="id"></field>
      <field name="primaryShipGroupSeqId" type="id"></field>
      <field name="picklistBinId" type="id"></field>
      <field name="estimatedReadyDate" type="date-time"></field>
      <field name="estimatedShipDate" type="date-time"></field>
      <field name="estimatedShipWorkEffId" type="id"></field>
      <field name="estimatedArrivalDate" type="date-time"></field>
      <field name="estimatedArrivalWorkEffId" type="id"></field>
      <field name="latestCancelDate" type="date-time"></field>
      <field name="estimatedShipCost" type="currency-amount"></field>
      <field name="currencyUomId" type="id"></field>
      <field name="handlingInstructions" type="long-varchar"></field>
      <field name="originFacilityId" type="id"></field>
      <field name="destinationFacilityId" type="id"></field>
      <field name="originContactMechId" type="id"></field>
      <field name="originTelecomNumberId" type="id"></field>
      <field name="destinationContactMechId" type="id"></field>
      <field name="destinationTelecomNumberId" type="id"></field>
      <field name="partyIdTo" type="id"></field>
      <field name="partyIdFrom" type="id"></field>
      <field name="additionalShippingCharge" type="currency-amount"></field>
      <field name="addtlShippingChargeDesc" type="long-varchar"></field>
      <field name="createdDate" type="date-time"></field>
      <field name="createdByUserLogin" type="id-vlong"></field>
      <field name="lastModifiedDate" type="date-time"></field>
      <field name="lastModifiedByUserLogin" type="id-vlong"></field>
      <prim-key field="shipmentId"/>
      <relation type="one" fk-name="SHPMNT_TYPE" rel-entity-name="ShipmentType">
        <key-map field-name="shipmentTypeId"/>
      </relation>
      <!-- 其他关系略 -->
    </entity>
```

### ShipmentItem 实体

OFBiz 的 ShipmentItem 实体定义：

```xml
    <entity entity-name="ShipmentItem"
            package-name="org.apache.ofbiz.shipment.shipment"
            title="Shipment Item">
      <field name="shipmentId" type="id"></field>
      <field name="shipmentItemSeqId" type="id"></field>
      <field name="productId" type="id"></field>
      <field name="quantity" type="fixed-point"></field>
      <field name="shipmentContentDescription" type="description"></field>
      <prim-key field="shipmentId"/>
      <prim-key field="shipmentItemSeqId"/>
      <relation type="one" fk-name="SHPMNT_ITM_SHPMT" rel-entity-name="Shipment">
        <key-map field-name="shipmentId"/>
      </relation>
      <relation type="one" fk-name="SHPMNT_ITM_PROD" rel-entity-name="Product">
        <key-map field-name="productId"/>
      </relation>
    </entity>
```

### ShippingDocument 实体

OFBiz 的 ShippingDocument 实体定义：

```xml
    <entity entity-name="ShippingDocument"
            package-name="org.apache.ofbiz.shipment.shipment"
            title="Shipping Document">
      <field name="documentId" type="id"></field>
      <field name="shipmentId" type="id"></field>
      <field name="shipmentItemSeqId" type="id"></field>
      <field name="shipmentPackageSeqId" type="id"></field>
      <field name="description" type="description"></field>
      <prim-key field="documentId"/>
      <relation type="one" fk-name="SHPNG_DOC_DOC" rel-entity-name="Document">
        <key-map field-name="documentId"/>
      </relation>
      <relation type="one" fk-name="SHPNG_DOC_SMITM" rel-entity-name="ShipmentItem">
        <key-map field-name="shipmentId"/>
        <key-map field-name="shipmentItemSeqId"/>
      </relation>
      <relation type="one" fk-name="SHPNG_DOC_SHPKG" rel-entity-name="ShipmentPackage">
        <key-map field-name="shipmentId"/>
        <key-map field-name="shipmentPackageSeqId"/>
      </relation>
    </entity>
```

### ASN (Advanced Shipping Notice)

ASN 是发货方在发货前或发货时向收货方发送的详细电子通知。

ASN 包含的信息：

1. **基础信息**
   - ASN 编号
   - 发送日期和时间
   - 预计到达日期（ETA）
2. **参与方信息**
   - 发货方信息
   - 收货方信息
   - 承运人信息
3. **参考文档**
   - 采购订单号
   - 销售订单号
   - 装运单号
   - 集装箱号
4. **货物信息**
   - 产品编号（SKU）
   - 批次号（Batch/Lot）
   - 序列号（Serial Number）
   - 数量和单位
   - 包装层次结构

似乎我们可以直接将 Shipping 实体用作 ASN 的“实现”。（如果有必要，可以利用 ShippingDocument 实体来记录 ASN 的额外信息。）


## OrderShipment 实体

OFBiz 的 OrderShipment 实体用于记录 Order 和 Shipment 之间的关联关系：

```xml
    <entity entity-name="OrderShipment"
            package-name="org.apache.ofbiz.order.order"
            never-cache="true"
            title="Order Shipment">
      <field name="orderId" type="id"></field>
      <field name="orderItemSeqId" type="id"></field>
      <field name="shipGroupSeqId" type="id"></field>
      <field name="shipmentId" type="id"></field>
      <field name="shipmentItemSeqId" type="id"></field>
      <field name="quantity" type="fixed-point"></field>
      <prim-key field="orderId"/>
      <prim-key field="orderItemSeqId"/>
      <prim-key field="shipGroupSeqId"/>
      <prim-key field="shipmentId"/>
      <prim-key field="shipmentItemSeqId"/>
      <relation type="one" fk-name="ORDER_SHPMT_OHDR" rel-entity-name="OrderHeader">
        <key-map field-name="orderId"/>
      </relation>
      <relation type="one-nofk" rel-entity-name="OrderItem">
        <key-map field-name="orderId"/>
        <key-map field-name="orderItemSeqId"/>
      </relation>
      <relation type="one" fk-name="ORDER_SHPMT_SHPMT" rel-entity-name="Shipment">
        <key-map field-name="shipmentId"/>
      </relation>
      <relation type="one-nofk" rel-entity-name="ShipmentItem">
        <key-map field-name="shipmentId"/>
        <key-map field-name="shipmentItemSeqId"/>
      </relation>
      <relation type="one-nofk" rel-entity-name="OrderItemShipGroupAssoc">
        <key-map field-name="orderId"/>
        <key-map field-name="orderItemSeqId"/>
        <key-map field-name="shipGroupSeqId"/>
      </relation>
    </entity>
```

但是 OrderShipment 实体中的“数量”更多可以理解为“计划数量”（所以预先发货通知的数量可以考虑记录在这里）。


## ShipmentReceipt 实体

和记录发货操作的 ItemIssuance 实体相对应，ShipmentReceipt 实体用于记录“收货”操作。

OFBiz 的 ShipmentReceipt 实体定义：

```xml
    <entity entity-name="ShipmentReceipt"
            package-name="org.apache.ofbiz.shipment.receipt"
            title="Shipment Receipt">
      <field name="receiptId" type="id"></field>
      <field name="inventoryItemId" type="id"></field>
      <field name="productId" type="id"></field>
      <field name="shipmentId" type="id"></field>
      <field name="shipmentItemSeqId" type="id"></field>
      <field name="shipmentPackageSeqId" type="id"></field>
      <field name="orderId" type="id"></field>
      <field name="orderItemSeqId" type="id"></field>
      <field name="returnId" type="id"></field>
      <field name="returnItemSeqId" type="id"></field>
      <field name="rejectionId" type="id"></field>
      <field name="receivedByUserLoginId" type="id-vlong"></field>
      <field name="datetimeReceived" type="date-time"></field>
      <field name="itemDescription" type="description"></field>
      <field name="quantityAccepted" type="fixed-point"></field>
      <field name="quantityRejected" type="fixed-point"></field>
      <prim-key field="receiptId"/>
      <relation type="one" fk-name="SHP_RCPT_INVITM" rel-entity-name="InventoryItem">
        <key-map field-name="inventoryItemId"/>
      </relation>
      <relation type="one" fk-name="SHP_RCPT_SHPKG" rel-entity-name="ShipmentPackage">
        <key-map field-name="shipmentId"/>
        <key-map field-name="shipmentPackageSeqId"/>
      </relation>
      <relation type="one" fk-name="SHP_RCPT_ORDITM" rel-entity-name="OrderItem">
        <key-map field-name="orderId"/>
        <key-map field-name="orderItemSeqId"/>
      </relation>
      <relation type="one-nofk" fk-name="SHP_RCPT_SHIPIT" rel-entity-name="ShipmentItem">
        <key-map field-name="shipmentId"/>
        <key-map field-name="shipmentItemSeqId"/>
      </relation>
      <relation type="one" fk-name="SHP_RCPT_RETINVITM" rel-entity-name="ReturnItem">
        <key-map field-name="returnId"/>
        <key-map field-name="returnItemSeqId"/>
      </relation>
      <!-- 其他关系略 -->
    </entity>
```

> 注：
> 
> 在 OFBiz 中，Return / ReturnItem（退货单）常常和特定类型的“装运单”相关联。
> 和退货相关的装运单类型通常包括 `PURCHASE_RETURN`（“我”退货/发货给“供应商”） 、`SALES_RETURN`（“客户”退货/发货给“我”）。


### 考虑如何实现“无订单”、“无装运单”收货

实际上项目中，各种“单据”的缺失是一个恼人但是又常见的问题。

如果我们允许 ShipmentReceipt 实体的 `orderId`，`shipmentId` 等字段为空，
那么似乎可以使用这个实体来记录“无订单”、“无装运单”的收货操作。

#### “临时收货单据”

一个可能的实现方案（使用“临时收货单据”）：

* 使用 Document 实体创建“临时收货单据”。（Temporary Receiving Document）
* 将这样的 Document 实体标记为特殊的类型（使用 `DocumentType` 实体）。
* 为 ShipmentReceipt 实体中添加一个属性 `receivingDocumentId`，引用上述的临时收货单形成“多对一”的关系。
* ShipmentReceipt 相当于“临时收货单”的行项（Item）。

考虑支持在收货后的“补录”操作。

* 允许在收货后，先补录采购订单，以及装运单的信息；
* 在用户界面上，允许将通过临时收货单（Document Id）查询出 ShipmentReceipt；
* 然后允许用户（通过“选择”的方式）将 ShipmentReceipt 的 `orderId`，`orderItemSeqId`，`shipmentId`，`shipmentItemSeqId` 关联到采购订单/订单行项、装运单/装运单行项。
* 也许还可以考虑不需要用户手动录入（以及选择）OrderItem、ShipmentItem，只需要录入 Order 和 Shipment 的信息，然后我们从 ShipmentReceipt 的记录“反推”应有的 OrderItem 和 ShipmentItem，自动“补录”并完成关联。
* 考虑将这些自动补录的 OrderItem 和 ShipmentItem 进行标记？
  * OFBiz 中存在 `OrderItemType` 实体；
  * 但是在 OFBiz 中不存在 `ShipmentItemType` 实体。


收货时，可能有关联的文档需要保存。如果这些文档也属于“Document”实体，那么，似乎需要引入一个 DocumentAssociation 实体。


#### 考虑使用“异步事件”机制

如果“自动补录”的逻辑比较复杂，可能需要考虑使用“异步事件”机制来处理。

另外，从“原始操作记录”生成食品追溯的 CTEs，可能也需要使用“异步事件”机制。

使用“异步事件”机制，可能会存在处理失败的情况。应对措施：

* 打印合适的日志，对日志进行兼容。
* 使用 scheduled task 机制，定期检查需要触发“异步事件处理”、但是没有处理成功的记录（“原始事件”），执行重试。


## ItemIssuance 实体

一般来说，ItemIssuance 实体在“实际发货”层面记录的、Order（订单）和 Shipment（装运单）之间的关联关系的实体。

但是如果我们允许 `orderId`，`shipmentId` 这些字段为空，那么这个实体可以记录“无订单”、“无装运单”的发货操作。

OFBiz 的 ItemIssuance 实体用于记录“发货”操作：

```xml
    <entity entity-name="ItemIssuance"
            package-name="org.apache.ofbiz.shipment.issuance"
            title="Item Issuance">
      <field name="itemIssuanceId" type="id"></field>
      <field name="orderId" type="id"></field>
      <field name="orderItemSeqId" type="id"></field>
      <field name="shipGroupSeqId" type="id"></field>
      <field name="inventoryItemId" type="id"></field>
      <field name="shipmentId" type="id"></field>
      <field name="shipmentItemSeqId" type="id"></field>
      <field name="fixedAssetId" type="id"></field>
      <field name="maintHistSeqId" type="id"></field>
      <field name="issuedDateTime" type="date-time"></field>
      <field name="issuedByUserLoginId" type="id-vlong"></field>
      <field name="quantity" type="fixed-point"></field>
      <field name="cancelQuantity" type="fixed-point"></field>
      <prim-key field="itemIssuanceId"/>
      <relation type="one" fk-name="ITEM_ISS_INVITM" rel-entity-name="InventoryItem">
        <key-map field-name="inventoryItemId"/>
      </relation>
      <relation type="one-nofk" rel-entity-name="OrderItemShipGrpInvRes">
        <key-map field-name="orderId"/>
        <key-map field-name="orderItemSeqId"/>
        <key-map field-name="shipGroupSeqId"/>
        <key-map field-name="inventoryItemId"/>
      </relation>
      <relation type="one-nofk" rel-entity-name="Shipment">
        <key-map field-name="shipmentId"/>
      </relation>
      <relation type="one" fk-name="ITEM_ISS_SHITM" rel-entity-name="ShipmentItem">
        <key-map field-name="shipmentId"/>
        <key-map field-name="shipmentItemSeqId"/>
      </relation>
      <relation type="one" fk-name="ITEM_ISS_FAMNT" rel-entity-name="FixedAssetMaint">
        <key-map field-name="fixedAssetId"/>
        <key-map field-name="maintHistSeqId"/>
      </relation>
      <relation type="one-nofk" rel-entity-name="OrderHeader">
        <key-map field-name="orderId"/>
      </relation>
      <relation type="one" fk-name="ITEM_ISS_ORITM" rel-entity-name="OrderItem">
        <key-map field-name="orderId"/>
        <key-map field-name="orderItemSeqId"/>
      </relation>
      <relation type="one" fk-name="ITEM_ISS_IBUL" title="IssuedBy" rel-entity-name="UserLogin">
        <key-map field-name="issuedByUserLoginId" rel-field-name="userLoginId"/>
      </relation>
    </entity>
```

在其他项目（Pmall 项目）中，我们也尝试过将这个实体建模为独立的聚合根——似乎这个设计更合理。

另外，在这个实体上加上 AttributeSetInstanceId 应该是有必要的，用于标识实际发货的产品的属性。


## Lot 实体

```xml
    <entity entity-name="Lot"
            package-name="org.apache.ofbiz.product.inventory"
            title="Lot">
      <field name="lotId" type="id"></field>
      <field name="creationDate" type="date-time"></field>
      <field name="quantity" type="fixed-point"></field>
      <field name="expirationDate" type="date-time"></field>
      <prim-key field="lotId"/>
    </entity>
```

### 考虑增加一个 LotIdentification 实体

Lot 实体的 lotId 字段，为了避免冲突，可能我们需要使用“内部 Lot Id”（类似自动生成的“代理键”）。

这里可以参考 PartyIdentification 实体的设计。类似这样：

```xml
     <entity entity-name="LotIdentification">
      <field name="lotId" type="id"></field>
      <field name="lotIdentificationTypeId" type="id"></field>
      <field name="idValue" type="id-long"></field>
      <prim-key field="partyId"/>
      <prim-key field="partyIdentificationTypeId"/>
      <relation type="one" fk-name="LOT_ID_TYPE" rel-entity-name="LotIdentificationType">
        <key-map field-name="lotIdentificationTypeId"/>
      </relation>
      <index name="LOT_ID_VALIDX" unique="false">
          <index-field name="idValue"/>
      </index>
    </entity> 
```

通过这个实体，可以将 Lot Id 映射到 GS1 标准的 BATCH/LOT 标识。

### GS1 BATCH/LOT (AI=10) 规范

#### 基本要求

1. **数据标识符**
   - Application Identifier (AI): 10
   - 用于标识批次或批号

2. **格式要求**
   - 最大长度：20个字符
   - 字符类型：字母数字（alphanumeric）
   - 可变长度
   - GS1 AI (10) = X₁₋₂₀ an

3. **字符集要求**
   - 可以包含数字 (0-9)
   - 可以包含大写字母 (A-Z)
   - 可以包含特殊字符（如 / - . _）
   - 建议避免使用可能造成混淆的字符

#### 最佳实践

1. **批号设计建议**
   - 保持一致的格式
   - 避免使用容易混淆的字符（如 I 和 1，O 和 0）
   - 考虑包含有意义的信息（如生产日期、生产线等）

2. **常见格式示例**
   ```
   ABC123        // 简单字母数字组合
   2023A123      // 年份+序列号
   L123456       // 生产线+序列号
   23001-A1      // 年月+序列号
   ```

#### 注意事项

1. **扫描考虑**
   - 确保打印质量清晰
   - 字符间距适当
   - 避免使用易混淆的字符组合

2. **系统集成**
   - 确保系统能够处理变长字段
   - 考虑数据库字段长度设置
   - 建议预留足够的字段长度（至少20字符）


## PartyIdentification 实体

```xml
     <entity entity-name="PartyIdentification"
            package-name="org.apache.ofbiz.party.party"
            title="Party Identification">
      <field name="partyId" type="id"></field>
      <field name="partyIdentificationTypeId" type="id"></field>
      <field name="idValue" type="id-long"></field>
      <prim-key field="partyId"/>
      <prim-key field="partyIdentificationTypeId"/>
      <relation type="one" fk-name="PARTY_ID_TYPE" rel-entity-name="PartyIdentificationType">
        <key-map field-name="partyIdentificationTypeId"/>
      </relation>
      <relation type="one" fk-name="PARTY_ID_PRODUCT" rel-entity-name="Party">
        <key-map field-name="partyId"/>
      </relation>
      <index name="PARTY_ID_VALIDX" unique="false">
          <index-field name="idValue"/>
      </index>
    </entity> 
```

### 使用 GGN (GLOBALG.A.P. Number)

GGN 是 GLOBALG.A.P. Number 的缩写：
   - GLOBALG.A.P. 编号
   - 由 GLOBALG.A.P. 组织分配的 13 位唯一标识符
   - 用于识别通过 GLOBALG.A.P. 认证的生产者或公司
   - 主要用于农业和水产养殖领域，表示符合良好农业规范标准

通过 PartyIdentification 可以将某个 PartyId 映射到 GGN。

### 使用 GLN (Global Location Number)

GLN (Global Location Number):
   - 全球位置编码
   - 由 GS1 分配的唯一标识符，用于识别公司、工厂、仓库等物理位置或法律实体
   - 在供应链中广泛使用，用于精确定位和识别参与者

可以通过 PartyIdentification 将 FacilityId 映射到 GLN。


## Facility（设施）实体

```xml
    <entity entity-name="Facility" package-name="org.apache.ofbiz.product.facility" title="Facility">
        <field name="facilityId" type="id"></field>
        <field name="facilityTypeId" type="id"></field>
        <field name="parentFacilityId" type="id"></field>
        <field name="ownerPartyId" type="id"/>
        <field name="defaultInventoryItemTypeId" type="id"></field>
        <field name="facilityName" type="name"></field>
        <field name="primaryFacilityGroupId" type="id"></field>
        <field name="facilitySize" type="fixed-point"></field>
        <field name="facilitySizeUomId" type="id"></field>
        <field name="productStoreId" type="id"></field>
        <field name="defaultDaysToShip" type="numeric"><description>In the absence of a product specific days to ship in ProductFacility, this will be used</description></field>
        <field name="openedDate" type="date-time"></field>
        <field name="closedDate" type="date-time"></field>
        <field name="description" type="description"></field>
        <field name="defaultDimensionUomId" type="id"><description>This field store the unit of measurement of dimension (length, width and height)</description></field>
        <field name="defaultWeightUomId" type="id"></field>
        <field name="geoPointId" type="id"></field>
        <field name="facilityLevel" type="numeric"><description>This field will define the level of facility.</description></field>
        <prim-key field="facilityId"/>
        <!-- 其他关系略 -->
    </entity>
```


### 考虑增加 FacilityIdentification 实体

考虑增加一个 FacilityIdentification 实体，以便支持将 FacilityId 映射到 FFRN 以及 GLN。

### 使用 FFRN (FDA Food Facility Registration Number)

FFRN (FDA Food Facility Registration Number):
   - FDA 食品设施注册号
   - 由美国食品和药物管理局 (FDA) 分配给食品生产、加工、包装或储存设施的唯一标识号
   - 根据生物恐怖主义法案要求，所有处理食品的设施都必须向 FDA 注册并获得此号码

### 使用 GLN (Global Location Number)

GLN (Global Location Number):
   - 全球位置编码
   - 由 GS1 分配的唯一标识符，用于识别公司、工厂、仓库等物理位置或法律实体
   - 在供应链中广泛使用，用于精确定位和识别参与者

可以通过 FacilityIdentification 将 FacilityId 映射到 GLN。


## Document 实体以及相关实体

Document 以及相关实体用于记录文档信息：

```xml
    <entity entity-name="Document"
            package-name="org.apache.ofbiz.content.document"
            title="Document">
      <field name="documentId" type="id"></field>
      <field name="documentTypeId" type="id"></field>
      <field name="dateCreated" type="date-time"></field>
      <field name="comments" type="comment"></field>
      <field name="documentLocation" type="long-varchar"></field>
      <field name="documentText" type="long-varchar"></field>
      <field name="imageData" type="object"></field>
      <prim-key field="documentId"/>
      <relation type="one" fk-name="DOCUMENT_TO_TYPE" rel-entity-name="DocumentType">
        <key-map field-name="documentTypeId"/>
      </relation>
      <relation type="many" rel-entity-name="DocumentTypeAttr">
        <key-map field-name="documentTypeId"/>
      </relation>
    </entity>

    <entity entity-name="DocumentAttribute"
            package-name="org.apache.ofbiz.content.document"
            title="Document Attribute">
      <field name="documentId" type="id"></field>
      <field name="attrName" type="id-long"></field>
      <field name="attrValue" type="value"></field>
      <field name="attrDescription" type="description"></field>
      <prim-key field="documentId"/>
      <prim-key field="attrName"/>
      <relation type="one" fk-name="DOCUMENT_ATTR" rel-entity-name="Document">
        <key-map field-name="documentId"/>
      </relation>
      <relation type="many" rel-entity-name="DocumentTypeAttr">
        <key-map field-name="attrName"/>
      </relation>
    </entity>
    <entity entity-name="DocumentType"
            package-name="org.apache.ofbiz.content.document"
            default-resource-name="ContentEntityLabels"
            title="Document Type">
      <field name="documentTypeId" type="id"></field>
      <field name="parentTypeId" type="id"></field>
      <field name="hasTable" type="indicator"></field>
      <field name="description" type="description"></field>
      <prim-key field="documentTypeId"/>
      <relation type="one" fk-name="DOC_TYPE_PARENT" title="Parent" rel-entity-name="DocumentType">
        <key-map field-name="parentTypeId" rel-field-name="documentTypeId"/>
      </relation>
    </entity>

    <entity entity-name="DocumentTypeAttr"
            package-name="org.apache.ofbiz.content.document"
            title="Document Type Attribute">
      <field name="documentTypeId" type="id"></field>
      <field name="attrName" type="id-long"></field>
      <field name="description" type="description"></field>
      <prim-key field="documentTypeId"/>
      <prim-key field="attrName"/>
      <relation type="one" fk-name="DOC_TYPE_ATTR" rel-entity-name="DocumentType">
        <key-map field-name="documentTypeId"/>
      </relation>
      <relation type="many" rel-entity-name="DocumentAttribute">
        <key-map field-name="attrName"/>
      </relation>
      <relation type="many" rel-entity-name="Document">
        <key-map field-name="documentTypeId"/>
      </relation>
    </entity>
```


## 考虑收货的 QA 操作

### 检验单（QaInspection）

属性：

- `qaInspectionId`: 检验单号
- `inspectedBy`: 检验员ID
- `inspectedAt`: 检验日期时间
- `inspectionTypeId`: 检验类型（收货/生产/出货）
- `statusId`: 状态（待检/检验中/已完成/已关闭）
- `productId`: 产品ID
- `lotId`: 批次 Id
- `sampleSize`: 抽样数量
- `sampleUomId`: 抽样单位
- `resultId`: 检验结果（合格/不合格/部分合格）
- `receiptId`: 关联的收货记录 Id
- `supplierPartyId`: 供应商ID
- `facilityId`: 仓库ID
- `qualityLevelId`: 质量等级
- `referenceDocs`: 相关单据号。**也许暂时不需要。如果需要，可能更好的方式是使用一个（聚合内）实体来记录关联的单据。**
- `comments`: 备注
- `createdAt`: 创建时间
- `updatedAt`: 更新时间

上面命名为 `xxxId` 的字段，会关联到其他实体，比如“QaInspectionType”、“QaInspectionResult”、“ProductQualityLevel”实体等。


### 检验项目（QaInspectionItem）

属性：

- `qaInspectionId`: 关联的检验单号
- `qaInspectionItemSeqId`: 检验项目 ID
- `qaCheckItemId`: 检验项目定义ID
- `standardValue`: 标准值
- `actualValue`: 实测值
- `toleranceUpper`: 上限公差
- `toleranceLower`: 下限公差
- `resultId`: 项目检验结果
- `defectQuantity`: 不合格数量
- `defectSeverityId`: 缺陷程度（严重/一般/轻微）
- `testEquipmentId`: 测试设备
- `measurementUnitId`: 测量单位，是否需要？
  - 这个名称含义不太明确。如果是“测量值”的单位，似乎可以命名为 `valueUomId`？
  - 如果需要，似乎可以作为关联的 `QaCheckItem` 实体中的属性就可以？
- `testCondition`: 测试条件。备注型字段？暂时不需要？
- `comments`: 备注
- `createdAt`: 创建时间



### 检验项目定义（QaCheckItem）

属性：

- `qaCheckItemId`: 检验项目定义ID
- `itemCode`: 项目代码
- `itemName`: 项目名称
- `itemType`: 项目类型（定性/定量）
- `checkMethod`: 检验方法，备注型字段？或者命名为 `comments` 或者 `checkMethodComments`？
- `standardValue`: 标准值
- `toleranceUpper`: 默认上限公差
- `toleranceLower`: 默认下限公差
- `isRequired`: 是否必检
- `active`: 是否启用
- `createdAt`: 创建时间


## Uom 实体

```xml
    <entity entity-name="Uom"
            package-name="org.apache.ofbiz.common.uom"
            default-resource-name="CommonEntityLabels"
            title="Unit Of Measure">
      <field name="uomId" type="id"></field>
      <field name="uomTypeId" type="id"></field>
      <field name="abbreviation" type="short-varchar"></field>
      <field name="numericCode" type="numeric"></field>
      <field name="description" type="description"></field>
      <prim-key field="uomId"/>
      <relation type="one" fk-name="UOM_TO_TYPE" rel-entity-name="UomType">
        <key-map field-name="uomTypeId"/>
      </relation>
    </entity>
```

### UOM 使用 GS1 Application Identifiers

参考：https://ref.gs1.org/ai/

在 Uom 实体中，`uomTypeId` 字段可以考虑使用 GS1 Application Identifiers 的 UOM 部分。

这类 UOM 使用特定的前缀？或者没有必要？比如 `GS1-3100` vs `3100`。但是 `uomTypeId` 字段需要明确标识为 GS1 Application Identifiers。


## Return 相关实体

OFBiz 中和“退货”相关的实体：

```xml
    <entity entity-name="ReturnHeader"
            package-name="org.apache.ofbiz.order.return"
            title="Return">
        <field name="returnId" type="id"></field>
        <field name="returnHeaderTypeId" type="id"></field>
        <field name="statusId" type="id"></field>
        <field name="createdBy" type="id-vlong"></field>
        <field name="fromPartyId" type="id"></field>
        <field name="toPartyId" type="id"></field>
        <field name="paymentMethodId" type="id"></field>
        <field name="finAccountId" type="id"></field>
        <field name="billingAccountId" type="id"></field>
        <field name="entryDate" type="date-time"></field>
        <field name="originContactMechId" type="id"></field>
        <field name="destinationFacilityId" type="id"></field>
        <field name="needsInventoryReceive" type="indicator"></field>
        <field name="currencyUomId" type="id"></field>
        <field name="supplierRmaId" type="id"></field>
        <prim-key field="returnId"/>
        <relation type="one" fk-name="RTN_HEAD_TYPE" rel-entity-name="ReturnHeaderType">
            <key-map field-name="returnHeaderTypeId"/>
        </relation>
        <!-- 其他关系略 -->
    </entity>

    <entity entity-name="ReturnItem"
            package-name="org.apache.ofbiz.order.return"
            title="Return Item">
        <field name="returnId" type="id"></field>
        <field name="returnItemSeqId" type="id"></field>
        <field name="returnReasonId" type="id" enable-audit-log="true">
            <description>why item is returned: did not like, wrong item, damaged, etc. etc.</description>
        </field>
        <field name="returnTypeId" type="id" enable-audit-log="true">
            <description>actually used for disbursement type: store credit, cash refund, exchange</description>
        </field>
        <field name="returnItemTypeId" type="id">
            <description>what is returned: a product, a service, etc</description>
        </field>
        <field name="productId" type="id">
            <description>we need this field to be able to figure out net sales of a product</description>
        </field>
        <field name="description" type="description"></field>
        <field name="orderId" type="id"></field>
        <field name="orderItemSeqId" type="id"></field>
        <field name="statusId" type="id"></field>
        <field name="expectedItemStatus" type="id"></field>
        <field name="returnQuantity" type="fixed-point" enable-audit-log="true"><description>promised by the customer</description></field>
        <field name="receivedQuantity" type="fixed-point" enable-audit-log="true"><description>actually received from the customer</description></field>
        <field name="returnPrice" type="currency-amount" enable-audit-log="true"></field>
        <field name="returnItemResponseId" type="id"></field>
        <prim-key field="returnId"/>
        <prim-key field="returnItemSeqId"/>
        <relation type="one" fk-name="RTN_ITEM_RTN" rel-entity-name="ReturnHeader">
            <key-map field-name="returnId"/>
        </relation>
        <relation type="one" fk-name="RTN_ITEM_TYPE" rel-entity-name="ReturnItemType"> <!-- this is new -->
            <key-map field-name="returnItemTypeId"/>
        </relation>
        <relation type="one" fk-name="RTN_ITEM_RESP" rel-entity-name="ReturnItemResponse">
            <key-map field-name="returnItemResponseId"/>
        </relation>
        <relation type="one" fk-name="RTN_ITEM_ITSTT" title="Inventory" rel-entity-name="StatusItem">
            <key-map field-name="expectedItemStatus" rel-field-name="statusId"/>
        </relation>
        <index name="RTN_ITM_BYORDITM">
            <index-field name="orderId"/>
            <index-field name="orderItemSeqId"/>
        </index>
        <!-- 其他关系略 -->
    </entity>
```

## OrderItemType 实体

```xml
    <entity entity-name="OrderItemType"
            package-name="org.apache.ofbiz.order.order"
            default-resource-name="OrderEntityLabels"
            title="Order Item Type">
      <field name="orderItemTypeId" type="id"></field>
      <field name="parentTypeId" type="id"></field>
      <field name="hasTable" type="indicator"></field>
      <field name="description" type="description"></field>
      <prim-key field="orderItemTypeId"/>
      <relation type="one" fk-name="ORDER_ITEM_TYPPAR" title="Parent" rel-entity-name="OrderItemType">
        <key-map field-name="parentTypeId" rel-field-name="orderItemTypeId"/>
      </relation>
    </entity>
```


### PhysicalInventory 实体

```xml
    <entity entity-name="PhysicalInventory"
            package-name="org.apache.ofbiz.product.inventory"
            title="Physical Inventory">
      <field name="physicalInventoryId" type="id"></field>
      <field name="physicalInventoryDate" type="date-time"></field>
      <field name="partyId" type="id"></field>
      <field name="generalComments" type="comment"></field>
      <prim-key field="physicalInventoryId"/>
    </entity>
```


## OFBiz 中关联到 InventoryItem 的实体

使用关键字 `"inventoryItemId"` 搜索 `*-entitymodel.xml` 文件，可以找到关联到 InventoryItem 的实体。

部分实体：

* InvoiceItem
* OrderItemShipGrpInvRes (Order Item Inventory Reservation)
* InventoryItemDetail
* InventoryItemVariance
* InventoryItemLabelAppl (Inventory Item Label Applicability)
* InventoryTransfer
* Subscription
* ItemIssuance
* PicklistItem
* ShipmentReceipt
* WorkEffortInventoryAssign
* WorkEffortInventoryProduced

## Party（业务实体）相关实体

OFBiz 中 PartyRole 实体的定义：

```xml
    <entity entity-name="PartyRole"
            package-name="org.apache.ofbiz.party.party"
            title="Party Role">
      <field name="partyId" type="id"></field>
      <field name="roleTypeId" type="id"></field>
      <prim-key field="partyId"/>
      <prim-key field="roleTypeId"/>
      <relation type="one" fk-name="PARTY_RLE_PARTY" rel-entity-name="Party">
        <key-map field-name="partyId"/>
      </relation>
      <relation type="one" fk-name="PARTY_RLE_ROLE" rel-entity-name="RoleType">
        <key-map field-name="roleTypeId"/>
      </relation>
      <relation type="many" rel-entity-name="RoleTypeAttr">
        <key-map field-name="roleTypeId"/>
      </relation>
      <relation type="many" rel-entity-name="PartyAttribute">
        <key-map field-name="partyId"/>
      </relation>
    </entity>
```



## Spring Security / Spring Authorization Server 相关 Schema


这些 Schema 会用于用户认证/授权管理。

```sql
create table users(
    username varchar_ignorecase(50) not null primary key,
    password varchar_ignorecase(100) not null,
    enabled boolean not null
);

create table authorities (
    username varchar_ignorecase(50) not null,
    authority varchar_ignorecase(50) not null,
    constraint fk_authorities_users foreign key(username) references users(username)
);

-- -------------------- 测试数据 --------------------
INSERT INTO users (username, password, enabled)
VALUES (
    'user',
    '{bcrypt}$2a$10$x1Q04LMJq8HX/J4AlRldZuNWIpjFevyNAP3OGUHPAbwLiGTHDVaJW',  -- 'password' 加密后的值
    true
);

INSERT INTO users (username, password, enabled)
VALUES ('admin', '{bcrypt}$2a$10$x1Q04LMJq8HX/J4AlRldZuNWIpjFevyNAP3OGUHPAbwLiGTHDVaJW', true);

INSERT INTO users (username, password, enabled)
VALUES ('superuser', '{bcrypt}$2a$10$x1Q04LMJq8HX/J4AlRldZuNWIpjFevyNAP3OGUHPAbwLiGTHDVaJW', true);

INSERT INTO authorities (username, authority)
VALUES ('user', 'ROLE_USER');

-- -- 普通用户
-- INSERT INTO authorities VALUES ('user', 'ROLE_USER');

-- 管理员
INSERT INTO authorities VALUES ('admin', 'ROLE_ADMIN');

-- 一个用户可以有多个角色
INSERT INTO authorities VALUES ('superuser', 'ROLE_USER');
INSERT INTO authorities VALUES ('superuser', 'ROLE_ADMIN');

```

### Group Authorities / 实现 RBAC（基于角色的访问控制）

Spring Security 的 Group Authorities 其实更接近大多数人认知的“角色”的概念。

我们可以使用 Group Authorities 来实现“基于角色的访问控制”。

Group Authorities 相关 Schema：

```sql
create table groups (
	id bigint generated by default as identity(start with 0) primary key,
	group_name varchar_ignorecase(50) not null
);

create table group_authorities (
	group_id bigint not null,
	authority varchar(50) not null,
	constraint fk_group_authorities_group foreign key(group_id) references groups(id)
);

create table group_members (
	id bigint generated by default as identity(start with 0) primary key,
	username varchar(50) not null,
	group_id bigint not null,
	constraint fk_group_members_group foreign key(group_id) references groups(id)
);

-- -------------------- 测试数据 --------------------

-- 1. 首先创建用户
INSERT INTO users (username, password, enabled) VALUES 
    ('bob', '{bcrypt}$2a$10$x1Q04LMJq8HX/J4AlRldZuNWIpjFevyNAP3OGUHPAbwLiGTHDVaJW', true),
    ('alice', '{bcrypt}$2a$10$x1Q04LMJq8HX/J4AlRldZuNWIpjFevyNAP3OGUHPAbwLiGTHDVaJW', true);

-- 2. 创建用户组（注意：需要显式指定 ID）
INSERT INTO groups (id, group_name) VALUES 
    (1, 'ADMIN_GROUP'),
    (2, 'USER_GROUP');

-- 3. 分配组权限（现在 group_id 1和2已经存在了）
INSERT INTO group_authorities (group_id, authority) VALUES 
    (1, 'ROLE_ADMIN'),
    (2, 'ROLE_USER');

-- 4. 最后将用户加入组
INSERT INTO group_members (username, group_id) VALUES 
    ('bob', 1),    -- bob 加入 ADMIN_GROUP
    ('alice', 2);  -- alice 加入 USER_GROUP

```

